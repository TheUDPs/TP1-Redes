#+LANGUAGE: es
#+OPTIONS: toc:nil title:nil

#+LATEX_CLASS_OPTIONS: [titlepage,a4paper]
#+LATEX_HEADER_EXTRA: \hypersetup{colorlinks=true,linkcolor=black,urlcolor=blue,bookmarksopen=true}
#+LATEX_HEADER_EXTRA: \usepackage{a4wide}
#+LATEX_HEADER_EXTRA: \usepackage{bookmark}
#+LATEX_HEADER_EXTRA: \usepackage{fancyhdr}
#+LATEX_HEADER_EXTRA: \usepackage[spanish]{babel}
#+LATEX_HEADER_EXTRA: \usepackage[utf8]{inputenc}
#+LATEX_HEADER_EXTRA: \usepackage[T1]{fontenc}
#+LATEX_HEADER_EXTRA: \usepackage{graphicx}
#+LATEX_HEADER_EXTRA: \usepackage{float}
#+LATEX_HEADER_EXTRA: \usepackage{minted}
#+LATEX_HEADER_EXTRA: \usepackage{svg}
#+LATEX_HEADER_EXTRA: \usepackage{xcolor}
#+LATEX_HEADER_EXTRA: \pagestyle{fancy}
#+LATEX_HEADER_EXTRA: \fancyhf{}
#+LATEX_HEADER_EXTRA: \fancyhead[L]{TP1: File Transfer - Grupo 2}
#+LATEX_HEADER_EXTRA: \fancyhead[R]{Redes - FIUBA}
#+LATEX_HEADER_EXTRA: \renewcommand{\headrulewidth}{0.4pt}
#+LATEX_HEADER_EXTRA: \fancyfoot[C]{\thepage}
#+LATEX_HEADER_EXTRA: \renewcommand{\footrulewidth}{0.4pt}
#+LATEX_HEADER_EXTRA: \usemintedstyle{stata-light}
#+LATEX_HEADER_EXTRA: \newminted{c}{bgcolor={rgb}{0.95,0.95,0.95}}
#+LATEX_HEADER_EXTRA: \usepackage{color}
#+LATEX_HEADER_EXTRA: \usepackage[utf8]{inputenc}
#+LATEX_HEADER_EXTRA: \usepackage{fancyvrb}
#+LATEX_HEADER_EXTRA: \fvset{framesep=1mm,fontfamily=courier,fontsize=\scriptsize,numbers=left,framerule=.3mm,numbersep=1mm}
#+LATEX_HEADER_EXTRA: \usepackage[nottoc]{tocbibind}
#+LATEX_HEADER_EXTRA: \usepackage{amsmath}
#+LATEX_HEADER_EXTRA: \usepackage{changepage}

#+NAME: setup
#+BEGIN_SRC emacs-lisp :results silent :exports none
  (setq org-latex-minted-options
    '(("bgcolor" "bg")))
#+END_SRC

#+BEGIN_EXPORT latex
\begin{titlepage}
    \hfill\includegraphics[width=6cm]{docs/imgs/logofiuba.jpg}
    \centering
    \vfill
    \Huge \textbf{Trabajo Práctico 1: File Transfer}
    \Large \textbf{Grupo 2}
    \vskip2cm
    \Large [TA048] Redes \\
    Primer cuatrimestre de 2025\\
    \vfill
    \begin{tabular}{ | l | l | l | }
      \hline
      Alumno & Padrón & Email \\ \hline
      AVALOS, Victoria & 108434 & vavalos@fi.uba.ar \\ \hline
      CASTRO MARTINEZ, Jose Ignacio & 106957 & jcastrom@fi.uba.ar \\ \hline
      CIPRIANO, Victor & 106593 & vcipriano@fi.uba.ar \\ \hline
      DEALBERA, Pablo Andres & 106858 & pdealbera@fi.uba.ar \\ \hline
      DIEM, Walter Gabriel & 105618 & wdiem@fi.uba.ar \\ \hline
    \end{tabular}
    \vfill
\end{titlepage}
\renewcommand{\contentsname}{Índice}
\tableofcontents
\newpage
\definecolor{bg}{rgb}{0.95,0.95,0.95}
#+END_EXPORT

* Introducción

En el presente trabajo práctico se desarrolla una aplicación de red para la transferencia de archivos, basada en una arquitectura
cliente-servidor, donde un servidor puede atender las operaciones de múltiples clientes de manera concurrente, con el objetivo principal de implementar mecanismos de transferencia de datos confiable. Para ello, se trabajará
sobre la capa de transporte, utilizando específicamente el protocolo UDP, lo cual requiere diseñar e implementar soluciones
personalizadas que garanticen la entrega de datos confiable (RDT - Reliable Data Transfer).

En este marco, se explorarán los principios del concepto de RDT, implementando dos de sus variantes: Stop-and-Wait (SAW) y Go-Back-N (GBN). La comunicación entre procesos se llevará a cabo mediante la interfaz de sockets de Python, y se utilizará la herramienta Mininet para simular diferentes
condiciones de red y evaluar el comportamiento de las implementaciones, incluyendo escenarios con pérdida de paquetes.


* Hipótesis y suposiciones realizadas

- La carga/descarga no va a conservar la metadata del archivo. Es decir, si yo descargo un archivo, ese archivo va a tener metadata como si yo hubiera creado el archivo desde cero usando `touch archivo`.
- Si el cliente utiliza otro protocolo para comunicarse con el server, el server debe rechazar este pedido, esta condición se la denominará *protocol mismatch*. El header tendrá un campo dedicado a la versión del protocolo.
- El argumento de FILENAME será opcional, en caso de no estar, se utiliza el nombre original del archivo.
- Por simplicidad, vamos a guardar todos los archivos en DIRPATH sin ningún nivel de subdirectorios.
- Si no se provee un DIRPATH para el storage del servidor, se utiliza el directorio actual.
- Se verifica que hayan 100 megas disponibles en el disco para realizar un upload al server.
- Si se cancela la carga o la descarga sin haberse finalizado correctamente, el archivo se borra.
- Si no se provee puerto por defecto se usa el 7777.
- Si no se provee un host por defecto será 127.0.0.1.
- El cliente hace un early bind con cualquier puerto UDP abierto disponible para uso justo antes de enviar el primer mensaje.
- Tanto el server como el cliente finalizan la conexión después de 30 segundos sin respuesta. También la conexión puede ser finalizada por exceder 300 retransmisiones del mismo paquete de manera continua, esta es una consideración de fácil cambio (dado que está definido en un archivo de constantes).
- Se eliminan los archivos corruptos no enviados/recibidos de manera completa.

* Implementación
** Topología propia LinearEnds

#+ATTR_LATEX: :width 0.5\textwidth
[[file:docs/imgs/linear_ends_multiple_clients_with_loss.png]]

La topología diseñada es una red lineal con 1 host servidor (izquierda) conectado a 3 switches en serie cuyo último switch esta conectado a *n* hosts clientes (derecha). El primer enlace (el conectado entre el servidor y el primer switch) tiene configurado un packet loss del 10% configurado de forma simétrica 5% en cada extremo del enlace.


** Especificación del protocolo Stop-and-Wait

*** General


*Formato de mensaje SaW*: \\


#+NAME: saw_format
#+BEGIN_SRC nil :eval never
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Pr|S|A|Y|F|     Unused      |               Port              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Payload Length       |               Data              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---------------------------------+
   |                           Data                                |
   +---------------------------------------------------------------+
#+END_SRC

Donde:

- ~Pr~: son los bits que determinan el protocolo (0 para SAW y 1 para GBN)
- ~S~: es el bit field que representa el sequence number, puede ser 0 o 1.
- ~A~: es el flag booleano que representa si el mensaje es un ACK o no.
- ~Y~: es el flag booleano que representa si el mensaje es SYN o no.
- ~F~: es el flag booleano que representa si el mensaje es FIN o no.
- ~Unused~: es una porción de bits que no se usa y queda como padding para completar el tamaño de un short unsigned int (2 bytes).
- ~Port~: el puerto con el que el receptor del mensaje debe comunicarse, se usa para el cambio de puerto.
- ~Payload length~: short unsigned int que representa el largo de la data que contiene el paquete.
- ~Data~: información binaria (bytes) que son los datos a transportar.

El header tiene un tamaño de 6 bytes. \\


*Tamaño máximo de payload* \\


El tamaño máximo de payload permitido por el protocolo está basado en el MTU establecido en el estándar Ethernet, es decir, 1500 bytes. Teniendo en cuenta que esto debería ser lo máximo que transporte un paquete de IP, se toman estos 1500 bytes como base, se le resta el tamaño de un header máximo de IP (60 bytes), lo mismo con el header de UDP (8 bytes) y se le resta el tamaño de header del protocolo (6 bytes). Quedando así un payload máximo de 1426 bytes.


*** Handshake

#+BEGIN_SRC plantuml :file docs/imgs/connection-handshake.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

Client ->(10) Server : [SYN]\nseq=0
Server ->(10) Client : [SYN], [ACK]\nseq=0

Client ->(10) Server : [ACK]\nseq=1\n data=1 (op_code)
Server ->(10) Client : [ACK]\nseq=1

@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.5\textwidth
#+RESULTS:
[[file:docs/imgs/connection-handshake.png]]

Este handshake se usa para inicialización de recursos del servidor y check de protocolo (que no haya protocol mismatch). \\

Se usa la nomenclatura S para mencionar al servidor y C para el cliente.

_Mensajes para caso Download y caso Upload_:

1. C \rightarrow S: con flag SYN para declarar una solicitud de conexión y el protocolo

*Flujo normal (mismo protocolo)*:

2. [@2] S \rightarrow C: con flag de SYN y ACK para declarar que se acepta la conexión y el puerto donde se va a escuchar el resto.
3. C \rightarrow S: con flag ACK al mismo welcoming socket.

*Flujo de error (distinto protocolo)*:

2. [@2] S \rightarrow C: con flag FIN para denegar la conexión por usar un protocolo distinto (protocol mismatch).

Se hace una transferencia de puerto para que el welcoming socket se encargue solamente de establecer conexiones y el nuevo puerto maneje la transferencia de datos del archivo. El último ACK de parte del cliente asegura que se recibió el puerto donde se tiene que comunicar y es seguro hacer el cambio de socket.

*** Etapa de configuración y Transferencia

El cliente ya sabe que tiene que comunicarse con el nuevo puerto.

Se envía primero la configuración para saber si la operación es válida, teniendo en cuenta casos de error, y luego se hace la transferencia. \\

_Mensajes para caso Download y caso Upload_:

1. C \rightarrow S: se declara la operación (OP), que puede ser download (1) o upload (2)
2. S \rightarrow C: ACK de la operación

_Continuación de mensajes para caso Download_:

3. [@3] Mensaje 3 C \rightarrow S: filename

*Flujo Normal*:

4. [@4] S \rightarrow C: ACK + comienzo de datos (piggybacked)
5. C \rightarrow S: ACK
6. S \rightarrow C: continuacion de datos

*Flujo de error (no existe un archivo con ese nombre)*:

4. [@4] S \rightarrow C: FIN, se termina la conexión

_Continuación de mensajes para caso Upload_:

3. [@3] C \rightarrow S: filename

*Flujo de error (ya existe un archivo con ese nombre)*:

4. [@4] S \rightarrow C: FIN, se termina la conexión

*Flujo normal*:

4. [@4] S \rightarrow C: ACK
5. C \rightarrow S: filesize

*Flujo de error (archivo es más grande que el tamaño máximo o [TODO] no hay más espacio en disco)*:

6. [@6] S \rightarrow C: FIN, se termina la conexión

*Flujo normal*:

6. [@6] S \rightarrow C: ACK
7. C \rightarrow S: comienzo de datos
8. S \rightarrow C: ACK
9. C \rightarrow S: continuacion de datos

*** Cierre

El flag FIN va piggybacked con la última data para que sea más eficiente. El receptor confirma con un ACK seguido de un FIN para que el emisor sepa que le llegó la información, y por si este se pierde está el último ACK para confirmar el cierre de parte del emisor. \\

Esto garantiza que se realice el esfuerzo máximo por parte del cliente y el servidor para, en primer lugar, asegurar le recepción del último chunk y, en segundo lugar, que ambos actores sepan que la conexión se va a cerrar y poder conseguir un graceful shutdown. En el peor de los casos se puede perder el último ACK, pero cuando eso pase, se hace el esfuerzo máximo para finalizar la conexión (hasta timeout o exceso de retransmissions). \\

_Mensajes para caso Download_

#+BEGIN_SRC plantuml :file docs/imgs/download.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

Server ->(10) Client : [FIN]\ndata Chunk n
Client ->(10) Server : [ACK]\nof data Chunk n
Client ->(10) Server : [FIN]
Server ->(10) Client : [ACK]

@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.5\textwidth
#+RESULTS:
[[file:docs/imgs/download.png]]

1. [@1] S \rightarrow C: última data, va piggybacked el flag FIN
2. C \rightarrow S: ACK
3. C \rightarrow S: FIN
4. S \rightarrow C: ACK

\\

_Mensajes para caso Upload:_

#+BEGIN_SRC plantuml :file docs/imgs/upload.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

Client ->(10) Server : [FIN]\ndata Chunk n
Server ->(10) Client : [ACK]\nof data Chunk n
Server ->(10) Client : [FIN]
Client ->(10) Server : [ACK]

@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.5\textwidth
#+RESULTS:
[[file:docs/imgs/upload.png]]

1. [@1] C \rightarrow S: última data, va piggybacked el flag FIN
2. S \rightarrow C: ACK
2. S \rightarrow C: FIN
3. C \rightarrow S: ACK


*** Ciclo de Vida de Upload

#+BEGIN_SRC plantuml :file docs/imgs/saw_upload.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

' Special invisible space to avoid bugged grouping
group ‎  [Handshake]

Client ->(10) Server : [SYN]\nseq=0
Server ->(10) Client : [SYN], [ACK]\nseq=0

Client ->(10) Server : [ACK]\nseq=1 \n data=2 (op_code)
Server ->(10) Client : [ACK]\nseq=1

else Configuration

Client ->(10) Server : seq=0 \n data=report.pdf
Server ->(10) Client : [ACK]\nseq=0

Client ->(10) Server : [ACK]\nseq=1 data=file_size
Server ->(10) Client : [ACK]\nseq=1

else File transfer

Client ->(10) Server : \nseq=0 \npayload_length=1426\n data=101110...

Server ->(10) Client : [ACK]\nseq=0

Client ->(10) Server : [FIN]\nseq=1 \npayload_length=100 \n data=101110...

else Closing handshake

Server ->(10) Client : [ACK]\nseq=1
Server ->(10) Client : [FIN]\nseq=1
Client ->(10) Server : [ACK]\nseq=0

end
@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.75\textwidth
#+RESULTS:
[[file:docs/imgs/saw_upload.png]]

\newpage

*** Análisis del Ciclo de Vida de Upload de una transferencia con Stop-and-Wait

En esta transferencia se utiliza el protocolo **Stop-and-Wait**, que asegura la entrega de datos mediante la espera de una confirmación (ACK) por cada paquete enviado antes de continuar. El archivo transferido es `report.pdf` y tiene un tamaño total de 1526 bytes.

**** Establecimiento de la conexión (Handshake):

- El **cliente** inicia la conexión enviando un paquete con el flag ~SYN~ y ~seq=0~.
- El **servidor** responde con un paquete con flags ~SYN~, ~ACK~ y ~seq=0~.
- El **cliente** confirma la recepción con un paquete ~ACK~ con ~seq=1~ y datos que indican el código de operación ~data=2~ (upload) al welcoming socket.
- El **servidor** responde con un ~ACK~ (~seq=1~) para confirmar la configuración de operación desde el socket al que la conexión fue transferida.

**** Configuración:

- El **cliente** envía un paquete con ~seq=0~ y ~data=report.pdf~, indicando el nombre del archivo como payload.
- El **servidor** responde con un paquete ~ACK~ (~seq=0~) para confirmar la recepción del nombre.
- El **cliente** envía otro paquete con ~seq=1~ y ~data=file_size~, indicando el tamaño del archivo como payload.
- El **servidor** responde con un ~ACK~ (~seq=1~).

**** Transferencia del archivo:

- El **cliente** envía un chunk de datos con ~seq=0~, ~payload_length=1426~, y datos binarios (~data=101110...~).

- El **servidor** responde con un ~ACK~ (~seq=0~), permitiendo al cliente continuar.

- El **cliente** envía un segundo y último paquete con ~FIN~, ~seq=1~, ~payload_length=100~, y más datos (~data=101110...~), indicando además el fin de la transferencia.

**** Cierre de la conexión (Closing handshake):

- El **servidor** confirma la recepción del último paquete con un ~ACK~ (~seq=1~).
- Luego, el **servidor** también inicia su cierre con un paquete ~FIN~ (~seq=1~).
- Finalmente, el **cliente** responde con un último ~ACK~ (~seq=0~), completando el cierre de la conexión.

*** Ciclo de Vida de Download

#+BEGIN_SRC plantuml :file docs/imgs/saw_download.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

' Special invisible space to avoid bugged grouping
group ‎  [Handshake]

Client ->(10) Server : [SYN]\nseq=0
Server ->(10) Client : [SYN], [ACK]\nseq=0

Client ->(10) Server : [ACK]\nseq=1 \n data=1 (op_code)
Server ->(10) Client : [ACK]\nseq=1

else Configuration

Client ->(10) Server : seq=0 \n data=report.pdf
Server ->(10) Client : [ACK]\nseq=0 \npayload_length=1426\n data=101110...
Client ->(10) Server : [ACK]\nseq=0

else File transfer

Server ->(10) Client : \nseq=1 \npayload_length=1426\n data=101110...

Client ->(10) Server : [ACK]\nseq=1

Server ->(10) Client : [FIN]\nseq=0 \npayload_length=100\n data=101110...

else Closing handshake

Client ->(10) Server : [ACK]\nseq=0
Client ->(10) Server : [FIN]\nseq=0
Server ->(10) Client : [ACK]\nseq=1

end
@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.75\textwidth
#+RESULTS:
[[file:docs/imgs/saw_download.png]]

\newpage

*** Análisis del Ciclo de Vida de Download de una transferencia con Stop-and-Wait

Esta transferencia ilustra el funcionamiento del protocolo Stop-and-Wait en una operación de descarga de archivos. El archivo solicitado por el cliente es report.pdf, con un tamaño total de 3000 bytes, dividido en fragmentos de máximo 1426 bytes. Cada paquete de datos enviado requiere una confirmación antes de que el servidor continúe con el siguiente.

**** Establecimiento de la conexión (Handshake):

- El cliente inicia la conexión con un paquete SYN con ~seq=0~.
- El servidor responde con un paquete que incluye los flags SYN y ACK (~seq=0~).
- El cliente confirma el establecimiento de la conexión con un ACK (~seq=1~) e indica en el cuerpo del mensaje el código de operación (~data=1~), correspondiente a una descarga.
- El servidor responde con otro ACK (~seq=1~), confirmando la recepción del código de operación.

**** Configuración:

- El cliente solicita el archivo enviando un paquete con ~seq=0~ y ~data=report.pdf~ como payload.
- El servidor, en lugar de enviar sólo un ACK, responde directamente con un ACK con el primer chunk de datos: ~seq=0~, ~payload_length=1426~, y ~data=101110....~
- El cliente confirma la recepción de este primer fragmento con un ACK (~seq=0~).

**** Transferencia del archivo:

- El servidor envía el segundo fragmento: ~seq=1~, ~payload_length=1426~, y ~data=101110...~.
- El cliente responde con un ACK (~seq=1~).

**** Cierre de la conexión (Closing handshake):

- El servidor, en el último chunk de datos indica el fin de la transmisión con un paquete FIN: ~seq=0~, ~payload_length=100~, y ~data=101110...~.
- El servidor confirma la recepción del último chunk con un ACK (~seq=0~).
- El cliente responde iniciando su propio cierre con un paquete FIN (~seq=0~).
- Finalmente, el cliente envía un último ACK (~seq=1~), completando el cierre de la conexión.

*** Manejo de retransmisiones

Ahora que se detalló los mensajes que se intercambian entre el cliente y el servidor, se presenta cómo maneja el protocolo una pérdida de paquetes.

La retransmisión se da siempre por parte de quien está esperando un mensaje, en otras palabras, quien esté bloqueado en un wait del socket tendrá la responsabilidad de re-enviar su último mensaje si no recibe lo que esperaba, o si no recibe nada. Se hace una retransmisión si en una determinada ventana de tiempo pre-establecida (15ms definido como una constante) no se recibe un mensaje, esto provee una rápida recuperación en la comunicación ante una pérdida de paquetes. Si el mensaje esperado es erróneo también se hace una retransmisión, ya que el socket podría estar leyendo un mensaje duplicado (retransmisión del otro participante de la interacción).

El accepter del servidor es un caso particular, es quien maneja el welcoming socket y hace la transferencia de la conexión a otro socket específico para ese flujo, y si recibe mensajes que no son un connection request para iniciar el handshake, o no son una continuación de un handshake en progreso, los rechaza y no retransmite.

** Especificación del protocolo Go-Back-N

*** General

*Formato de mensaje GBN*: \\

#+NAME: gbn_format
#+BEGIN_SRC nil :eval never
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Pr|A|Y|F|       Unused      |               Port              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Payload length                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Sequence number                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Acknowledge number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Data                              |
   +---------------------------------------------------------------+
#+END_SRC

Donde:

- ~Pr~: son los bits que determinan el protocolo (0 para SAW y 1 para GBN)
- ~A~: es el flag booleano que representa si el mensaje es un ACK o no.
- ~Y~: es el flag booleano que representa si el mensaje es SYN o no.
- ~F~: es el flag booleano que representa si el mensaje es FIN o no.
- ~Unused~: es una porción de bits que no se usa y queda como padding para completar el tamaño de un short unsigned int (2 bytes).
- ~Port~: el puerto con el que el receptor del mensaje debe comunicarse, se usa para el cambio de puerto.
- ~Payload length~: unsigned int (4 bytes) que representa el largo de la data que contiene el paquete.
- ~Sequence number~: unsigned int (4 bytes) que representa el número de secuencia del paquete.
- ~Acknowledge number~: unsigned int (4 bytes) que representa el número de acknowledge, usado principalmente para saber cuál fue el último paquete que se recibió.
- ~Data~: información binaria (bytes) que son los datos a transportar.

El header tiene un tamaño de 16 bytes. \\

*Tamaño máximo de payload* \\

El tamaño se determina análogamente a SAW, sólo que esta vez se le resta el tamaño de header del protocolo (16 bytes). Quedando así un payload máximo de 1416 bytes.


*** Ciclo de Vida de Upload

#+BEGIN_SRC plantuml :file docs/imgs/gbn_upload.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

' Special invisible space to avoid bugged grouping
group ‎  [Handshake]

Client ->(10) Server : [SYN]\nseq=0, ack=0
Server ->(10) Client : [SYN], [ACK]\nseq=0, ack=0

Client ->(10) Server : [ACK]\nseq=1, ack=1\n data=2 (op_code)
Server ->(10) Client : [ACK]\nseq=1, ack=1

else Configuration

Client ->(10) Server : seq=2, ack=2\n data=report.pdf
Server ->(10) Client : [ACK]\nseq=2, ack=2

Client ->(10) Server : seq=3, ack=3\n data=3000
Server ->(10) Client : [ACK]\nseq=3, ack=3

else File transfer

Client ->(10) Server : seq=4, ack=4\npayload_length=1416\n data=101110...
Client ->(10) Server : seq=5, ack=4\npayload_length=1416\n data=101110...

Server ->(10) Client : [ACK]\nseq=4, ack=4
Server ->(10) Client : [ACK]\nseq=5, ack=5

else Closing handshake

Client ->(10) Server : [FIN]\nseq=6, ack=5\npayload_length=168\n data=101110...

Server ->(10) Client : [ACK]\nseq=6, ack=6
Server ->(10) Client : [FIN]\nseq=6, ack=6

Client ->(10) Server : [ACK]\nseq=7, ack=6

end

caption \nGo-Back-N protocol with window of\n 2 packets. Client uploads file \n(report.pdf of size 3000 bytes) to server

@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.65\textwidth
#+RESULTS:
[[file:docs/imgs/gbn_upload.png]]

*** Análisis del Ciclo de Vida de Upload de una transferencia con Go-Back-N

Se observa el comportamiento de una transferencia de archivos con una ventana de tamaño 2. En este caso, el cliente sube un archivo (report.pdf) de 3000 bytes al servidor.

**** Establecimiento de la conexión (Handshake):

- El cliente inicia la conexión enviando un paquete con el flag ~SYN~, con ~seq=0~ y ~ack=0~.
- El servidor responde con un paquete con flags ~SYN~ y ~ACK~, manteniendo los mismos valores de seq y ack.
- El cliente confirma la recepción enviando un paquete ~ACK~ con ~seq=1~ y ~ack=1~, incluyendo en datos la configuración del código de operación (en este caso de subida) ~data=2~ (op_code).
- El servidor responde con un ~ACK~ para confirmar la recepción del mensaje de configuración (~seq=1~, ~ack=1~).

**** Configuración:

- El cliente envía un paquete con ~seq=2~, ~ack=2~ y ~data=report.pdf~, indicando el nombre del archivo a subir.
- El servidor responde con un paquete ~ACK~ (~seq=2~, ~ack=2~) para confirmar la petición.
- El cliente envía un paquete con ~seq=3~, ~ack=3~ y ~data=3000~, informando el tamaño total del archivo en bytes.
- El servidor confirma la recepción de esta información con otro ~ACK~ (~seq=3~, ~ack=3~).

**** Transferencia del archivo:

- El cliente envía el primer chunk de datos con ~seq=4~, ~ack=4~, ~payload_length=1416~ y ~data=101110~.
- A continuación, envía el segundo chunk con ~seq=5~, ~ack=4~, ~payload_length=1416~ y ~data=101110~.
- El servidor confirma la recepción del primer chunk enviando un ~ACK~ (~seq=4~, ~ack=4~).
- Luego, confirma el segundo chunk con otro ~ACK~ (~seq=5~, ~ack=5~).

**** Cierre de la conexión (Closing handshake):

- El cliente inicia el cierre enviando un paquete ~FIN~ con ~seq=6~, ~ack=5~, ~payload_length=168~ y ~data=101110~.
- El servidor responde con un ~ACK~ final (~seq=6~, ~ack=6~).
- El servidor envía a su vez un paquete ~FIN~ (~seq=6~, ~ack=6~) para cerrar su lado de la comunicación.
- Finalmente, el cliente completa el cierre con un último ~ACK~ (~seq=7~, ~ack=6~).

*** Ciclo de Vida de Download

#+BEGIN_SRC plantuml :file docs/imgs/gbn_download.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

' Special invisible space to avoid bugged grouping
group ‎  [Handshake]

Client ->(10) Server : [SYN]\nseq=0, ack=0
Server ->(10) Client : [SYN], [ACK]\nseq=0, ack=0

Client ->(10) Server : [ACK]\nseq=1, ack=1\n data=1 (op_code)
Server ->(10) Client : [ACK]\nseq=1, ack=1

else Configuration

Client ->(10) Server : seq=2, ack=2\n data=report.pdf
Server ->(10) Client : [ACK]\nseq=2, ack=2\npayload_length=1416\n data=101110...
Client ->(10) Server : [ACK]\nseq=2, ack=2

else File transfer

Server ->(10) Client : seq=3, ack=2\npayload_length=1416\n data=101110...
Server ->(10) Client : [FIN]\nseq=4, ack=2\npayload_length=168\n data=101110...

Client ->(10) Server : [ACK]\nseq=3, ack=3
Client ->(10) Server : [ACK]\nseq=4, ack=4

else Closing handshake

Client ->(10) Server : [FIN]\nseq=4, ack=4
Server ->(10) Client : [ACK]\nseq=5, ack=5

end

caption \nGo-Back-N protocol with window of\n 2 packets. Client downloads file \n(report.pdf of size 3000 bytes) from server
@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.7\textwidth
#+RESULTS:
[[file:docs/imgs/gbn_download.png]]

\newpage

*** Análisis del Ciclo de Vida de Download de una transferencia con Go-Back-N

Se observa el comportamiento de una transferencia de archivos con una ventana de tamaño 2. En
este caso, el cliente descarga un archivo (`report.pdf`) de 3000 bytes desde el servidor.

**** Establecimiento de la conexión (Handshake):
- El cliente inicia la conexión enviando un paquete con el flag ~SYN~, con ~seq=0~ y ~ack=0~.
- El servidor responde con un paquete con flags ~SYN~ y ~ACK~ manteniendo los mismos valores de ~seq~ y ~ack~.
- El cliente confirma la recepción enviando un paquete ~ACK~ con ~seq=1~ y ~ack=1~, incluyendo en datos la configuración del código de operación (en este caso de descarga) ~data=1 (op_code)~.
- El servidor responde con un ~ACK~ para confirmar la recepción del mensaje de operación.

**** Configuración:
- El cliente envía un paquete con ~seq=2~, ~ack=2~ y ~data=report.pdf~, indicando el nombre del archivo a descargar.
- El servidor responde con un paquete de datos con ~seq=2~, ~ack=2~, una ~size~ de 1416 bytes y los primeros bits del archivo.
- El cliente confirma la recepción con un ~ACK~ correspondiente.

**** Transferencia del archivo:
- El servidor envía el segundo ~chunk~ de datos (~seq=3~, ~ack=2~), también de 1416 bytes.
- Posteriormente, se envía un paquete con el flag ~FIN~ (~seq=4~, ~ack=2~, ~payload_length=168~), marcando el último chunk.
- El cliente responde con dos ~ACK~, uno para cada paquete recibido correctamente: ~seq=3, ack=3~ y ~seq=4, ack=4~.

**** Cierre de la conexión (Closing handshake):
- El cliente envía un ~FIN~ para finalizar su lado de la comunicación (~seq=4, ack=4~).
- El servidor responde con un ~ACK~ final (~seq=5, ack=5~), completando el cierre de la conexión de manera ordenada.

\newpage

*** Manejo de retransmisiones

Para la sección de handshake y configuración se sigue la misma forma de actuar del protocolo SAW ante una necesidad de retransmisión.

Durante la etapa de transferencia del archivo, la parte de la transmisión que actúa de sender tiene la responsabilidad de re-enviar toda la ventana que tiene disponible desde el último paquete que fue confirmado con un ACK por parte del receiver. Para que el sender pueda considerar un paquete correctamente confirmado debe tener el mismo ACK number que está esperando recibir o que haya llegado un ACK con ACK number mayor, por lo que se entiende que el receiver recibió correctamente todos los paquetes hasta el ACK number que envío. Esto último despeja de repente una buena porción de la ventana para enviar consecutivamente nuevos paquetes. El tamaño de la ventana utilizado, que mediante comprobación empírica es el que mejor resultados trajo, es de tamaño de 10 paquetes.

* Análisis

En esta sección compararemos el performance de los protocolos Go Back N y Stop & Wait bajo distintas configuraciones de pérdida de paquetes y utilizando archivos de distintos tamaños.

** Upload

| **File Size** | **SAW (0%)** | **SAW (10%)** | **SAW (40%)** | **GBN (0%)** | **GBN (10%)** | **GBN (40%)** |
|---------------|--------------|---------------|---------------|--------------|---------------|---------------|
| **6 MB**      | 0.3748s      | 6.2843s       | 29.1048s      | 0.2684s      | 2.8044s       | 11.9307s      |
| **25 MB**     | 1.3594s      | 27.1792s      | 123.2692s     | 0.8491s      | 11.9623s      | 51.3981s      |

** Download

| **File Size** | **SAW (0%)** | **SAW (10%)** | **SAW (40%)** | **GBN (0%)** | **GBN (10%)** | **GBN (40%)** |
|---------------|--------------|---------------|---------------|--------------|---------------|---------------|
| **6 MB**      | 0.3745s      | 6.1496s       | 28.1998s      | 0.2326s      | 2.5937s       | 11.6761s      |
| **25 MB**     | 1.6736s      | 27.7168s      | 120.4340s     | 1.0254s      | 11.7572s      | 51.7844s      |


* Pruebas

Se presentan capturas de diferentes casos de uso de la aplicación.

** Casos de error

- Protocol Mismatch

\noindent \includegraphics[width=\textwidth]{docs/imgs/protocol_mismatch.png}
\captionof{figure}{Ejemplo de protocol mismatch.}

En caso de que un cliente intente conectarse con un servidor utilizando un protocolo diferente al suyo, el servidor lo rechazará. En la imagen se puede observar un ejemplo en el que un servidor que utiliza Stop & Wait rechaza a un cliente que hace una petición con Go Back N.

- Archivo ya existente

\noindent \includegraphics[width=\textwidth]{docs/imgs/file_already_exists.png}
\captionof{figure}{Ejemplo de upload de un archivo que ya existe en el servidor.}

Para ambos protocolos, si el cliente intenta subir un archivo que el servidor ya tiene, se rechaza.

- Descarga de un archivo que no existe

\noindent \includegraphics[width=\textwidth]{docs/imgs2/error_file_doesnt_exist.png}
\captionof{figure}{Ejemplo de intento de descarga de un archivo que no existe.}

Para ambos protocolos, si el cliente intenta descargar un archivo que el servidor no posee, se rechaza.

** Stop & Wait

Para mostrar el funcionamiento de Stop & Wait, mostraremos las capturas de las operaciones upload y download de un archivo pequeño de 5kB a modo de ejemplo. Primero sin pérdida de paquetes, y luego con una pérdida del 10% utilizando mininet.

*** Stop & Wait sin pérdida de paquetes

- Upload

\noindent \includegraphics[width=\textwidth]{docs/imgs/saw_upload_logs.png}
\captionof{figure}{Captura de los logs de Upload con Stop and Wait.}


\noindent \includegraphics[width=\textwidth]{docs/imgs/saw_upload_wireshark.png}
\captionof{figure}{Captura de wireshark de Upload con Stop and Wait.}

- Download

\noindent \includegraphics[width=\textwidth]{docs/imgs/saw_download_logs.png}
\captionof{figure}{Captura de los logs de Download con Stop and Wait.}

\noindent \includegraphics[width=\textwidth]{docs/imgs/saw_download_wireshark.png}
\captionof{figure}{Captura de wireshark de Download con Stop and Wait.}

*** Stop & Wait con pérdida de paquetes del 10%

- Upload

\noindent \includegraphics[width=\textwidth]{docs/imgs2/saw_10l_up.png}
\captionof{figure}{Captura de los logs de Upload con Stop and Wait con pérdida del 10 por ciento.}


\noindent \includegraphics[width=\textwidth]{docs/imgs2/saw_10l_up_ws.png}
\captionof{figure}{Captura de wireshark de Upload con Stop and Wait con pérdida del 10 por ciento.}

- Download

\noindent \includegraphics[width=\textwidth]{docs/imgs2/saw_10l_down.png}
\captionof{figure}{Captura de los logs de Download con Stop and Wait con pérdida del 10 por ciento.}

\noindent \includegraphics[width=\textwidth]{docs/imgs2/saw_10l_down_ws.png}
\captionof{figure}{Captura de wireshark de Download con Stop and Wait con pérdida del 10 por ciento.}

** Go Back N

Para mostrar el funcionamiento de Go Back N, mostraremos las capturas de las operaciones upload y download del mismo archivo de 5kB. Para este caso, mostraremos únicamente el caso con pérdida de paquetes, ya que el escenario con pérdida resulta muy similar al de Stop & Wait debido a que la ventana que utilizamos es mayor a la cantidad de paquetes que posee este archivo.

- Upload

\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_up.png}
\captionof{figure}{Captura de los logs de Upload con Go Back N.}


\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_up_ws.png}
\captionof{figure}{Captura de wireshark de Upload con Go Back N.}

- Download

\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_down.png}
\captionof{figure}{Captura de los logs de Download con Go Back N.}

\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_down_ws.png}
\captionof{figure}{Captura de wireshark de Download con Go Back N.}

** Pruebas automatizadas

Si bien se detallaron ejemplos manuales donde se probaron las características del protocolo de aplicación desarrollado, también se desarrollaron pruebas automatizadas con /pytest/, siendo ventajoso el hecho de que Mininet está desarrollo en Python y ofrece una API.

Se desarrollaron pruebas de integración que testean:

- Upload y download correcto.
- Caso download cuando la ubicación de guardado del archivo a descargar ya existe.
- Caso download cuando el archivo a descargar no existe en el servidor.
- Caso upload cuando la ubicación del archivo a subir no existe.
- Caso download cuando el archivo a subir ya existe en el servidor con el nombre proveído.
- Caso de comunicación fallida por protocol mismatch entre servidor y clientes.
- Caso de descargas y subida múltiples y simultáneas.

Todas estas pruebas se ejecutan, cada una, bajo las siguientes condiciones:

- Protocolo SAW con 0% de packet loss.
- Protocolo SAW con 10% de packet loss.
- Protocolo SAW con 40% de packet loss.
- Protocolo GBN con 0% de packet loss.
- Protocolo GBN con 10% de packet loss.
- Protocolo GBN con 40% de packet loss.

Estas pruebas generan un alto consumo de CPU y poseen una cota de tiempo (establecida para que en el CI/CD no consuma recursos de más) por lo que requieren de hardware adecuado.

* Preguntas a Responder
** Describa la arquitectura Cliente-Servidor.
La arquitectura Cliente-Servidor es una de dos arquitecturas más comunes. En esta arquitectura hay un /host/ (/end system/) llamado /server/ que esta siempre encendido que pasivamente escucha /requests/ de otros /hosts/ llamados /clients/ que son agentes activos que inician la comunicación con el /server/.

Un ejemplo de esta arquitectura es una aplicacion Web donde hay un /Web server/ que escucha /requests/ de navegadores web. El navegador web es el cliente que inicia la comunicación y el /Web server/ es el servidor que responde a los /requests/. Estos mensajes tienen el formato de Capa de Aplicación HTTP.

*** Caracteristicas
 - Los clientes son agentes activos que inician la comunicación.
 - Los clientes no se comunican entre sí.
 - Los clientes no necesitan estar encendidos todo el tiempo ni tener una IP fija.
 - Los servidores son pasivos y siempre están encendidos.
 - Los servidores *deben* tener una IP fija bien conocida (/well-known IP address/) que se puede resolver con un nombre de dominio DNS (/domain name/).
 - Los servidores pueden tener múltiples clientes conectados al mismo tiempo.

*** Ventajas
 - Diseño simple usando protocolos sin estado como HTTP donde el servidor no
   necesita mantener información sobre clientes ya que se puede guardar
   información del cliente en /cookies/ del cliente y estos se transmitidos en
   /headers/ HTTP.
 - Puede soportar un gran número de clientes.

*** Desventajas
 - Un solo punto de falla. Si el servidor se cae, el servicio se cae.
 - El servidor debe estar encendido todo el tiempo.
 - Gran costo para escalar, ya que a medida de que el servicio tiene más
   usuarios, el servidor debe también aumentar su capacidad de procesar más
   clientes.

** ¿Cuál es la función de un protocolo de capa de aplicación?

Un protocolo de capa de aplicación especifica cómo los procesos de una aplicación, que se ejecutan en diferentes sistemas finales, intercambian mensajes entre sí. Este tipo de protocolo define:

- Los tipos de mensajes que se envían, como mensajes de solicitud y de respuesta.

- La sintaxis de los mensajes, es decir, la estructura de los campos dentro de cada mensaje y cómo se separan o identifican esos campos.

- La semántica de los campos, indicando qué significa la información contenida en cada uno.

- Las reglas de comunicación, que establecen cuándo un proceso debe enviar un mensaje y cómo debe reaccionar al recibir uno.

En resumen, los protocolos de capa de aplicación aseguran que las aplicaciones puedan comunicarse correctamente y coordinarse en la red, haciendo posible servicios como el correo electrónico, la web o la transferencia de archivos.

** Detalle el protocolo de aplicación desarrollado en este trabajo.

Este apartado fue detallado y explicado en la sección [[*Implementación][*Implementación*]].

** La capa de transporte del stack TCP/IP ofrece dos protocolos: TCP y UDP.

*** ¿Qué servicios proveen dichos protocolos?

Ambos protocolos proveen los siguientes servicios:

- *Multiplexación/Demultiplexación*: son los mecanismos que permiten extender el servicio de entrega de IP entre dos end systems a un servicio de entrega entre dos procesos que se ejecutan en esos sistemas. Dichos mecanismos permiten identificar a qué proceso pertenece cada segmento recibido.
- *Chequeo de integridad*: se verifica que no haya errores en los datos mediante un campo de checksum en los headers de ambos protocolos.

UDP no realiza ninguna otra función extra. Por lo tanto, su servicio es:
- *No confiable*: no garantiza que la entrega de los paquetes sea exitosa, ni tampoco que lleguen en orden.
- *Sin conexión*: cada paquete datagrama se envía de manera independiente, sin garantías de que el receptor esté listo o incluso disponible.

Por su parte, TCP ofrece las siguientes funcionalidades adicionales:
- *Orientado a la conexión*: antes de que un proceso de aplicación pueda comenzar a enviar datos a otro, ambos procesos deben comunicarse entre sí; es decir, deben enviarse algunos segmentos preliminares para establecer los parámetros de la transferencia de datos subsiguiente. Se trata de una conexión lógica con un estado en común que reside en TCP de los hosts.
- *Transferencia de datos confiable*: garantiza la entrega, el orden y la no corrupción de los datos. Esto lo logra mediante timers, números de secuencia y ACKs (flags que indican que un paquete fue entregado correctamente).
- *Control de congestión*: gestiona que no se saturen los enlaces. Es más bien un servicio para la red.
- *Control de flujo*: para eliminar la posibilidad de que el remitente desborde el buffer del receptor. Hace coincidir la velocidad a la que el remitente envía con la velocidad a la que la aplicación receptora lee.

*** ¿Cuáles son sus características?

Algunas de las características de UDP son las siguientes:
- *Pequeño overhead de header por paquete*: UDP posee un header pequeño (8 bytes) en comparación con TCP (20 bytes)
- *Sin estado de conexión*: UDP no mantiene un estado de conexión en los end systems, por lo que no rastrea ningún parámetro. Por esta razón, un servidor dedicado a una aplicación específica generalmente puede admitir muchos más clientes activos cuando la aplicación se ejecuta mediante UDP en lugar de TCP.
- *Sin retraso por conexión*: UDP no induce ningún retraso para establecer una conexión, a diferencia de TCP que posee un handshake de tres pasos.

Por su parte, TCP posee las siguientes características:

- *Full-duplex*: dada una conexión TCP entre dos hosts, digamos A y B, la información puede fluir de A a B al mismo tiempo que fluye información de B a A.
- *Conexión point-to-point*: la conexión de TCP únicamente se puede establecer entre un único remitente y un único receptor, no admite multicasting.
- *Three-Way Handshake*: para establecer la conexión mencionada anteriormente se realiza un procedimiento donde se envían tres segmentos.

*** ¿Cuándo es apropiado utilizar cada uno?

Ninguno de estos protocolos es mejor que el otro. Para decidir cuál de ellos utilizar, se deben tener en cuenta las necesidades de la aplicación.
Debido a las características mencionadas anteriormente, UDP resulta más apropiado para aplicaciones que requieran mayor velocidad sin que sea tan sensible a algunas pérdidas de paquetes, por ejemplo plataformas de streaming, y si se tiene un servidor dedicado a una aplicación específica que necesita poder admitir muchos más clientes activos.
Por otro lado, TCP es más ventajoso para las aplicaciones que necesitan un transporte confiable de los datos. Algunos ejemplos son el email y la web.

* Anexo: Fragmentación IPv4
** Enunciado :noexport:
El siguiente ejercicio se plantea como objetivo la comprensión y la puesta en
práctica de los conceptos y herramientas necesarias para la comprobación del
proceso de fragmentación en IPv4. Para lograr este objetivo, se deberá crear
una red virtual que contenga la topología propuesta y se deberá generar tráfico
para poder analizar el comportamiento del protocolo IPv4:

 - Utilizando mininet. se pide armar una topología lineal formada por dos hosts conectados a través de 3 switches.
 - Reducir el MTU de alguna interfaz del switch central. Configurar un packet loss en una interfaz del switch conectada
 - al segundo host.
 - Generar tráfico UDP/TCP utilizando iperf. Configurar el tamaño de los paquetes de manera tal que se produzca el
 - proceso de fragmentación.
 - Capturar el tráfico utilizando wireshark.
 - Analizar el tráfico generado en la topología y comprobar empíricamente los siguientes fenómenos:
 - Proceso de fragmentación
 - Funcionamiento de TCP ante la pérdida de un fragmento
 - Funcionamiento de UDP ante la pérdida de un fragmento
 - Aumento de tráfico al reducirse el MTU mínimo de la red.

** Consideraciones iniciales

Se propuso inicialmente una red de topología lineal que una a:
- Un host servidor
- Tres switches conectados en serie
- Un host cliente

Donde haya pérdida de paquetes en el enlace próximo al host receptor y que el switch central tenga la capacidad de fragmentar paquetes que excedan el MTU de alguna de sus interfaces.


Sin embargo, los switches en mininet no tienen la capacidad de fragmentar paquetes, por lo que forzar este fenómeno causaría una pérdida total de todo paquete de tamaño mayor al MTU. Conceptualmente un switch, al ser un elemento de Link Layer, no debe tener la capacidad de fragmentar paquetes de otra capa de red.
La solución propuesta fue sustituir ese switch central por un "router" central, un tipo de nodo de mininet similar a los hosts pero que además cuenta con la capacidad de hacer forwarding de paquetes IPv4.


Otro de los conflictos presentados es la comunicación bidireccional. Reducir el MTU de alguna interfaz de un router implica que se reduce sobre el enlace de esta interfaz. Y si este enlace está conectado a un router y a un switch, la comunicación andará bien en sentido router \rightarrow switch pero se perderán los paquetes en el sentido switch \rightarrow router.


Por lo tanto, si se desea una tráfico bidireccional de paquetes excedentes al MTU de alguna de las interfaces de la ruta esta NO debe estar vinculada a un switch, de lo contrario se perderá todo paquete que exceda el MTU reducido. Dicho esto, se decidió arbitrariamente que basta con tener comunicación unidireccional (C \rightarrow S) para poder provocar el fenómeno de fragmentación de paquetes.

** Análisis
*** Topología
\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/linear_ends_fragmentation_item.png}
\captionof{figure}{Red con un servidor, dos switches, un router y un cliente}

Se define una pérdida de 20% de paquetes sobre el enlace próximo al servidor, un MTU de 800 en la interfaz saliente del router (s2-eth0) y un tamaño de paquetes de 1000B siendo ambos valores elegidos arbitrariamente, basta con generar tráfico de paquetes de tamaño superior al MTU reducido para estudiar este fenómeno.

*** Proceso de fragmentación

Habiendo definido la red como se mencionó anteriormente, se genera tráfico de cliente a servidor usando iperf y se capturan los paquetes recibidos y enviados por las interfaces del router (s2) con Wireshark para estudiar este fenómeno. Por ejemplo:

\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/s2-eth1_tcp.png}
\captionof{figure}{Paquetes capturados en interfaz de entrada del router (s2-eth1)}

\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/s2-eth0_tcp.png}
\captionof{figure}{Paquetes capturados en interfaz de salida del router (s2-eth0)}

Una vez establecida la conexión TCP, los paquetes que superan el MTU de la interfaz de salida son fragmentados por el router. Cada fragmento se encapsula en su propio datagrama IPv4 (con el mismo Identification y flags MF/Offset adecuados) y se envía por la red.

\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/frag_packet_1.png}
\captionof{figure}{Secuencia de un paquete fragmentado (1) a detalle}

\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/frag_packet_2.png}
\captionof{figure}{Secuencia de un paquete fragmentado (2) a detalle}

Wireshark agrupa los fragmentos bajo un mismo “Reassembled in #” basándose en el Identification y los offsets; tras inspeccionar la columna de secuencia TCP, se puede  mapear fácilmente cada fragmento al segmento original. Si un segmento requiere más de dos fragmentos, se observará varios “Reassembled in #” con offsets crecientes. Sin embargo, cabe destacar que el reensamblado ocurre únicamente en el host destino, no en el router. Esto debido a que si cada router tuviese que reensamblar paquetes sería un proceso muy costoso y afectaría al rendimiento de la red.

Sumando las longitudes de los fragmentos observamos que el router termina transmitiendo más datos que los recibidos originalmente: esto se debe a que cada fragmento es un paquete en si mismo, y por cada fragmento generado es un nuevo header.

*** Funcionamiento de TCP ante la pérdida de un fragmento
TCP es un protocolo de transporte que maneja la retransmisión de datos tras pérdida y detección a partir de ACKs duplicados. Este fenómeno es muy simple de visualizar en Wireshark, donde se señala en la columna de información cuando un paquete corresponde a información retransmitida.

Cuando un paquete TCP es demasiado grande para pasar por una interfaz con un MTU pequeño y no tiene activado el bit "Don't Fragment", el router lo fragmenta a nivel IP. Esto significa que el paquete IP original se divide en varios fragmentos IP, cada uno con su propio encabezado IP, pero todos parte del mismo datagrama original.

Los fragmentos no se reensamblan en los routers intermedios sino que el host de destino es quien reensambla todos los fragmentos en el paquete IP original antes de entregárselo al stack TCP.

\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/tcp_retransmission.png}
\captionof{figure}{Retransmisión TCP vista en el router}

Es decir, si se pierde un solo fragmento, el paquete IP no puede ser reensamblado, y por lo tanto no llega al protocolo TCP. El sistema operativo desecha todos los fragmentos recibidos de ese datagrama después de un tiempo de espera (timeout).

Desde el punto de vista de TCP nunca ve los fragmentos individuales. Solo sabe que no recibió un segmento TCP completo porque fue descartado en capa IP.

De esta forma, TCP en el servidor no responde porque no tiene nada que confirmar y TCP en el cliente eventualmente detecta la pérdida (por timeout o falta de ACK) y retransmite el segmento TCP completo.

Capturando el output del comando iperf (ejecutado durante 3 segundos) se puede observar el resultado final de la comunicación en cliente y servidor:

\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/iperf_client_tcp.png}
\captionof{figure}{Captura de iperf TCP desde cliente}

\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/iperf_server_tcp.png}
\captionof{figure}{Captura de iperf TCP desde servidor}

*** Funcionamiento de UDP ante la pérdida de un fragmento

UDP no es un protocolo orientado a la transferencia confiable de datos, por lo que NO cuenta con ningún mecanismo tras pérdida de paquetes, solamente envía sin garantía de recepción.

En estas capturas de Wireshark se evidencia como ocurre el fenómeno de fragmentación, donde al solo fragmentar en 2 un paquete UDP en Wireshark se capturará cerca del doble de paquetes en cada interfaz (o más según la relación tamaño/MTU):

\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/s2-eth1_udp.png}
\captionof{figure}{Paquetes capturados en interfaz de entrada del router (s2-eth1)}

\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/s2-eth0_udp.png}
\captionof{figure}{Paquetes capturados en interfaz de salida del router (s2-eth0)}

Sin embargo, al haber pérdida de paquetes cercano al servidor, esta no puede observarse capturando sobre el router sino sobre el servidor, donde se observaría que tantos paquetes se pierden a partir de que tantos envió el cliente. Otra forma más sencilla de observar este fenómeno es con el output del comando iperf ejecutado sobre UDP, donde explícitamente señala que cantidad de paquetes se perdieron.

\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/iperf_client_udp.png}
\captionof{figure}{Captura de iperf UDP desde cliente}

\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/iperf_server_udp.png}
\captionof{figure}{Captura de iperf UDP desde servidor}

Donde se observa una pérdida en torno al 20% definido inicialmente.

*** Aumento de tráfico al reducirse el MTU mínimo de la red.

Por último, el fenómeno más sencillo de comprobar. Como se mencionó anteriormente, ya que el router fragmenta paquetes de ambos protocolos de transporte en función de su tamaño y el MTU de la interfaz de salida, siempre va a enviar más paquetes de los que recibe, por lo que se observa un aumento notorio del tráfico en la red. Para esta experiencia, se observa un aumento trabajando con UDP:

\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/s2-eth1_udp_last_packets.png}
\captionof{figure}{Paquetes capturados en interfaz de entrada del router (s2-eth1)}

\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/s2-eth0_udp_last_packets.png}
\captionof{figure}{Paquetes capturados en interfaz de salida del router (s2-eth0)}

Y se observa también un aumento en el tráfico de la red trabajando con TCP:

\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/s2-eth1_tcp_last_packets.png}
\captionof{figure}{Paquetes capturados en interfaz de entrada del router (s2-eth1)}

\noindent \includegraphics[width=\textwidth]{docs/frag_imgs/s2-eth0_tcp_last_packets.png}
\captionof{figure}{Paquetes capturados en interfaz de salida del router (s2-eth0)}


* Dificultades Encontradas

** Mininet

Inicialmente se tuvo que entender de manera profunda cómo funciona Mininet, para poder crear una topología modularizable en 3 apartados: cantidad de clientes, porcentaje de packet loss y reducción de MTU. Se tuvo que leer la documentación y documentación creada por la comunidad para lograr el cometido y crear una topología robusta.

A pesar de las dificultados quedamos satisfechos e incluso esto nos permitió compartir la topología con la feature de reducción de MTU con nuestros compañeros de manera pública a pedido del profesor, se puede encontrar esto en este link: [[https://github.com/gabrieldiem/linear-ends-topology-with-ip-frag][Linear ends topology with IP fragmentation]].

** Protocolo SAW

Teniendo sólida la teoría de cómo debería funcionar el protocolo nos encontramos con el problema de cómo, técnicamente, realizar la retransmisión, además de qué criterio tomar para espaciarlas y cuántas deberían haber.

Despúes de intentar con un enfoque poco escalable en términos de código (notamos que iba a haber mucha repetición de código) usando ciclos /while/ en cada método que queríamos que retransmitiera, evolucionamos la idea a utilizar el patrón /decorator/, para manejar las veces que una recepción del socket se debería llevar a cabo, y un ciclo while genérico, aplicado a una abstracción del socket que hicimos (clase /SocketSaw/), para realizar las retransmisiones.

Este cambio de enfoque permitió destrabar progresivamente los problemas de debugging que nos fuimos encontrando a lo largo del TP, e.g. sequence number incorrecto, socket trabado en receive, entre otros.

** Protocolo GBN

En términos de avance del proyecto, primero desarrollamos el procolo SAW, por lo que para el comienzo del desarrollo del protocolo GBN ya teníamos el conocimiento de ejecución y el código ya armado para el SAW.

De esta manera, analizamos y tomamos la decisión de mantener las etapas de handshake, configuración y closing handshake de SAW, ya que esto no tenía sentido hacerlo de manera GBN, teniendo en cuenta los pocos paquetes que son, en comparación a un envío de archivo de miles de paquetes.

Esto llevó a realizar un manejo especial del primer y último chunk dentro de la base de código para asegurar el RDT, chunks que se podrían considerar como la ``transición'' entre modos de comunicación.

Al comienzo del proyecto debatimos sobre si usar un mismo formato de header para ambos protocolos o si utilizar dos distintos. La decisión que tomamos fue utilizar un header apropiado para cada protocolo, de tal manera no arrastraríamos decisiones tomadas para GBN (como el ACK number, o el tamaño del sequence number) que no tienen sentido para SAW.

** Plugin de Wireshark

Se encontraron dificultades para armar el plugin dinámico que reconozca el protocolo que se esta utilizando y a partir de ello realizar el formateo del contenido del paquete, con lo cual, se adquirieron los conocimientos básicos del uso del lenguaje de programación Lua y también de la integración de dicho lenguaje con la herramienta Wireshark.

* Conclusión

El desarrollo de este trabajo práctico permitió consolidar conceptos fundamentales sobre la comunicación entre procesos en redes de computadoras, especialmente aquellos vinculados a la capa de transporte y a los mecanismos necesarios para lograr una transferencia de datos confiable (RDT) sobre el protocolo UDP. La implementación de los protocolos Stop-and-Wait y Go-Back-N brindó una comprensión más profunda de los desafíos involucrados en el diseño de mecanismos de retransmisión y confirmación.

Desde una perspectiva empírica, se comprobó que Go-Back-N ofrece un rendimiento superior al de Stop-and-Wait, dado que reduce la espera por confirmaciones al permitir el envío continuo de múltiples paquetes. Sin embargo, se evidenció la importancia de seleccionar adecuadamente el tamaño de ventana, ya que un valor grande puede generar que la retransmisión demore mucho.

Por otro lado, el uso de la interfaz de sockets en Python y la simulación de red mediante Mininet proporcionaron un entorno realista para evaluar el comportamiento de las implementaciones bajo condiciones adversas, como la pérdida de paquetes. En conjunto, el trabajo permitió articular teoría y práctica, fortaleciendo las habilidades necesarias para el diseño e implementación de protocolos de red personalizados.

\newpage

* Bibliografía

\bibitem{rfc-udp}
\textit{User Datagram Protocol RFC768 - IETF}. Disponible en: \url{https://www.ietf.org/rfc/rfc768.txt}. Recuperado en Abril del 2025.

\bibitem{rfc-tcp}
\textit{Transmission Control Protocol RFC793 - IETF}. Disponible en: \url{https://www.ietf.org/rfc/rfc793.txt}. Recuperado en Abril del 2025.

\bibitem{rdt}
James F. Kurose and Keith W. Ross, *Computer Networking: A Top-Down Approach*, 8th ed., Pearson, 2021. Chapter 3.4: Principles of Reliable Data Transfer. Recuperado en Abril del 2025.
