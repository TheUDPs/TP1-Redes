#+LANGUAGE: es
#+OPTIONS: toc:nil title:nil

#+LATEX_CLASS_OPTIONS: [titlepage,a4paper]
#+LATEX_HEADER_EXTRA: \hypersetup{colorlinks=true,linkcolor=black,urlcolor=blue,bookmarksopen=true}
#+LATEX_HEADER_EXTRA: \usepackage{a4wide}
#+LATEX_HEADER_EXTRA: \usepackage{bookmark}
#+LATEX_HEADER_EXTRA: \usepackage{fancyhdr}
#+LATEX_HEADER_EXTRA: \usepackage[spanish]{babel}
#+LATEX_HEADER_EXTRA: \usepackage[utf8]{inputenc}
#+LATEX_HEADER_EXTRA: \usepackage[T1]{fontenc}
#+LATEX_HEADER_EXTRA: \usepackage{graphicx}
#+LATEX_HEADER_EXTRA: \usepackage{float}
#+LATEX_HEADER_EXTRA: \usepackage{minted}
#+LATEX_HEADER_EXTRA: \usepackage{svg}
#+LATEX_HEADER_EXTRA: \usepackage{xcolor}
#+LATEX_HEADER_EXTRA: \pagestyle{fancy}
#+LATEX_HEADER_EXTRA: \fancyhf{}
#+LATEX_HEADER_EXTRA: \fancyhead[L]{TP1 - Grupo 2}
#+LATEX_HEADER_EXTRA: \fancyhead[R]{Redes - FIUBA}
#+LATEX_HEADER_EXTRA: \renewcommand{\headrulewidth}{0.4pt}
#+LATEX_HEADER_EXTRA: \fancyfoot[C]{\thepage}
#+LATEX_HEADER_EXTRA: \renewcommand{\footrulewidth}{0.4pt}
#+LATEX_HEADER_EXTRA: \usemintedstyle{stata-light}
#+LATEX_HEADER_EXTRA: \newminted{c}{bgcolor={rgb}{0.95,0.95,0.95}}
#+LATEX_HEADER_EXTRA: \usepackage{color}
#+LATEX_HEADER_EXTRA: \usepackage[utf8]{inputenc}
#+LATEX_HEADER_EXTRA: \usepackage{fancyvrb}
#+LATEX_HEADER_EXTRA: \fvset{framesep=1mm,fontfamily=courier,fontsize=\scriptsize,numbers=left,framerule=.3mm,numbersep=1mm}
#+LATEX_HEADER_EXTRA: \usepackage[nottoc]{tocbibind}
#+LATEX_HEADER_EXTRA: \usepackage{amsmath}
#+LATEX_HEADER_EXTRA: \usepackage{changepage}

#+NAME: setup
#+BEGIN_SRC emacs-lisp :results silent :exports none
  (setq org-latex-minted-options
    '(("bgcolor" "bg")))
#+END_SRC

#+BEGIN_EXPORT latex
\begin{titlepage}
    \hfill\includegraphics[width=6cm]{docs/imgs/logofiuba.jpg}
    \centering
    \vfill
    \Huge \textbf{Trabajo Práctico 1}
    \vskip2cm
    \Large [TA048] Redes \\
    Primer cuatrimestre de 2025\\
    \vfill
    \begin{tabular}{ | l | l | l | }
      \hline
      Alumno & Padron & Email \\ \hline
      AVALOS, Victoria & 108434 & vavalos@fi.uba.ar \\ \hline
      CASTRO MARTINEZ, Jose Ignacio & 106957 & jcastrom@fi.uba.ar \\ \hline
      CIPRIANO, Victor & 106593 & vcipriano@fi.uba.ar \\ \hline
      DEALBERA, Pablo Andres & 106858 & pdealbera@fi.uba.ar \\ \hline
      DIEM, Walter Gabriel & 105618 & wdiem@fi.uba.ar \\ \hline
    \end{tabular}
    \vfill
\end{titlepage}
\tableofcontents
\newpage
\definecolor{bg}{rgb}{0.95,0.95,0.95}
#+END_EXPORT

* Introducción

En el presente trabajo práctico se desarrolla una aplicación de red para la transferencia de archivos, basada en una arquitectura
cliente-servidor, donde un servidor puede atender las operaciones de múltiples clientes de manera concurrente, con el objetivo principal de implementar mecanismos de transferencia de datos confiable. Para ello, se trabajará
sobre la capa de transporte, utilizando específicamente el protocolo UDP, lo cual requiere diseñar e implementar soluciones
personalizadas que garanticen la entrega de datos confiable (RDT - Reliable Data Transfer).

En este marco, se explorarán los principios del concepto de RDT, implementando dos de sus variantes: Stop-and-Wait (SAW) y Go-Back-N (GBN). La comunicación entre procesos se llevará a cabo mediante la interfaz de sockets de Python, y se utilizará la herramienta Mininet para simular diferentes
condiciones de red y evaluar el comportamiento de las implementaciones, incluyendo escenarios con pérdida de paquetes.


* Hipótesis y suposiciones realizadas

- La carga/descarga no va a conservar la metadata del archivo. Es decir, si yo descargo un archivo, ese archivo va a tener metadata como si yo hubiera creado el archivo desde cero usando `touch archivo`.
- Si el cliente utiliza otro protocolo para comunicarse con el server, el server debe rechazar este pedido, esta condición se la denominará *protocol mismatch*. El header tendrá un campo dedicado a la versión del protocolo.
- El argumento de FILENAME sera opcional, en caso de no estar, se utiliza el nombre original del archivo.
- Por simplicidad, vamos a guardar todos los archivos en DIRPATH sin ningún nivel de subdirectorios.
- Si no se provee un DIRPATH para el storage del servidor, se utiliza el directorio actual.
- Se verifica que hayan 100 megas disponibles en el disco para realizar un upload al server.
- Si se cancela la carga o la descarga sin haberse finalizado correctamente, el archivo se borra.
- Si no se provee puerto por defecto se usa el 7777.
- Si no se provee un host por defecto será 127.0.0.1.
- El cliente hace un early bind con cualquier puerto UDP abierto disponible para uso justo antes de enviar el primer mensaje.
- Tanto el server como el cliente finalizan la conexión después de 30 segundos sin respuesta. También la conexión puede ser finalizada por exceder 300 retransmisiones del mismo paquete de manera continua.
- Se eliminan los archivos corruptos no enviados/recibidos de manera completa.

* Implementación
** Topología propia LinearEnds

#+ATTR_LATEX: :width 0.5\textwidth
[[file:docs/imgs/linear_ends_multiple_clients_with_loss.png]]

La topología diseñada es una red lineal con 1 host servidor (izquierda) conectado a 3 switches en serie cuyo ultimo switch esta conectado a *n* hosts clientes (derecha). El primer enlace (el conectado entre el servidor y el primer switch) tiene configurado un packet loss del 10% configurado de forma simetrica 5% en cada extremo del enlace.


** Especificación del protocolo Stop-and-Wait

*** General


*Formato de mensaje SaW*: \\


#+NAME: saw_format
#+BEGIN_SRC nil :eval never
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Pr|S|A|Y|F|     Unused      |               Port              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Payload Length       |               Data              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---------------------------------+
   |                           Data                                |
   +---------------------------------------------------------------+
#+END_SRC

Donde:

- ~Pr~: son los bits que determinan el protocolo (0 para SAW y 1 para GBN)
- ~S~: es el bit field que representa el sequence number, puede ser 0 o 1.
- ~A~: es el flag booleano que representa si el mensaje es un ACK o no.
- ~Y~: es el flag booleano que representa si el mensaje es SYN o no.
- ~F~: es el flag booleano que representa si el mensaje es FIN o no.
- ~Unused~: es una porción de bits que no se usa y queda como padding para completar el tamaño de un short unsigned int (2 bytes).
- ~Port~: el puerto con el que el receptor del mensaje debe comunicarse, se usa para el cambio de puerto.
- ~Payload length~: short unsigned int que representa el largo de la data que contiene el paquete.
- ~Data~: información binaria (bytes) que son los datos a transportar.

El header tiene un tamaño de 6 bytes. \\


*Tamaño máximo de payload* \\


El tamaño máximo de payload permitido por el protolo está basado en el MTU establecido en el estándar Ethernet, es decir, 1500 bytes. Teniendo en cuenta que esto debería ser lo máximo que transporte un paquete de IP, se toman estos 1500 bytes como base, se le resta el tamaño de un header máximo de IP (60 bytes), lo mismo con el header de UDP (8 bytes) y se le resta el tamaño de header del protocolo (6 bytes). Quedando así un payload máximo de 1426 bytes.


*** Handshake

#+BEGIN_SRC plantuml :file docs/imgs/connection-handshake.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

Client ->(10) Server : [SYN]\nseq=0, ack=0
Server ->(10) Client : [SYN], [ACK]\nseq=0, ack=0

Client ->(10) Server : [ACK]\nseq=1, ack=1\n data=1 (op_code)
Server ->(10) Client : [ACK]\nseq=1, ack=1

@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.5\textwidth
#+RESULTS:
[[file:docs/imgs/connection-handshake.png]]

La idea es usar este handshake para inicialización de recursos del servidor y check de protocolo (que no haya protocol mismatch). \\

Se usa la nomenclatura S para mencionar al servidor y C para el cliente.

_Mensajes para caso Download y caso Upload_:

1. C \rightarrow S: con flag SYN para declarar una solicitud de conexión y el protocolo

*Flujo normal (mismo protocolo)*:

2. [@2] S \rightarrow C: con flag de SYN y ACK para declarar que se acepta la conexión y el puerto donde se va a escuchar el resto.
3. C \rightarrow S: con flag ACK al mismo welcoming socket.

*Flujo de error (distinto protocolo)*:

2. [@2] S \rightarrow C: con flag FIN para denegar la conexión por usar un protocolo distinto (protocol mismatch).

Se hace una transferencia de puerto para que el welcoming socket se encargue solamente de establecer conexiones y el nuevo puerto maneje la transferencia de datos del archivo. El último ACK de parte del cliente asegura que se recibió el puerto donde se tiene que comunicar y es seguro hacer el cambio de socket.

*** Etapa de configuración y Transferencia

El cliente ya sabe que tiene que comunicarse con el nuevo puerto.

Se envía primero la configuración para saber si la operación es válida y tener en cuenta casos de error, y luego se hace la transferencia. \\

_Mensajes para caso Download y caso Upload_:

1. C \rightarrow S: se declara la operación (OP), que puede ser download (1) o upload (2)
2. S \rightarrow C: ACK de la operación

_Continuación de mensajes para caso Download_:

3. [@3] Mensaje 3 C \rightarrow S: filename

*Flujo Normal*:

4. [@4] S \rightarrow C: ACK + comienzo de datos (piggybacked)
5. C \rightarrow S: ACK
6. S \rightarrow C: continuacion de datos

*Flujo de error (no existe un archivo con ese nombre)*:

4. [@4] S \rightarrow C: FIN, se termina la conexión

_Continuación de mensajes para caso Upload_:

3. [@3] C \rightarrow S: filename

*Flujo de error (ya existe un archivo con ese nombre)*:

4. [@4] S \rightarrow C: FIN, se termina la conexión

*Flujo normal*:

4. [@4] S \rightarrow C: ACK
5. C \rightarrow S: filesize

*Flujo de error (archivo es más grande que el tamaño máximo o [TODO] no hay más espacio en disco)*:

6. [@6] S \rightarrow C: FIN, se termina la conexión

*Flujo normal*:

6. [@6] S \rightarrow C: ACK
7. C \rightarrow S: comienzo de datos
8. S \rightarrow C: ACK
9. C \rightarrow S: continuacion de datos

*** Cierre

El flag FIN va piggybacked con la última data para que sea más eficiente. El receptor confirma con un ACK + FIN para que el emisor sepa que le llego la informacion, y por si este se pierde está el último ACK para confirmar el cierre de parte del emisor. \\

**** Mensajes para caso Download

#+BEGIN_SRC plantuml :file docs/imgs/download.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

Client ->(10) Server : Filename
Server ->(10) Client : ACK, Data Chunk 1 (piggybacked)
Client ->(10) Server : ACK of Data Chunk 1
Server ->(10) Client : Data Chunk 2
Client ->(10) Server : ACK of Data Chunk 2
Server ->(10) Client : ...
Client ->(10) Server : ...
Server ->(10) Client : FIN, Data Chunk n
Client ->(10) Server : FIN, ACK of Data Chunk n
@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.5\textwidth
#+RESULTS:
[[file:docs/imgs/download.png]]

1. S \rightarrow C: ultima data, va piggybacked el flag FIN
2. C \rightarrow S: ACK + FIN
3. S \rightarrow C: ACK

**** Mensajes para caso Upload:

#+BEGIN_SRC plantuml :file docs/imgs/upload.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

Client ->(10) Server : Filename
Server ->(10) Client : ACK
Client ->(10) Server : Filesize
Server ->(10) Client : ACK
Client ->(10) Server : Data
@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.5\textwidth
#+RESULTS:
[[file:docs/imgs/upload.png]]

1. C \rightarrow S: ultima data, va piggybacked el flag FIN
2. S \rightarrow C: ACK + FIN
3. C \rightarrow S: ACK

*** Ejemplo del Ciclo de Vida



** Especificación del protocolo Go-Back-N

*** General

*Formato de mensaje GBN*: \\

#+NAME: gbn_format
#+BEGIN_SRC nil :eval never
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Pr|A|Y|F|       Unused      |               Port              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Payload length                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Sequence number                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Acknowledge number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Data                              |
   +---------------------------------------------------------------+
#+END_SRC

Donde:

- ~Pr~: son los bits que determinan el protocolo (0 para SAW y 1 para GBN)
- ~A~: es el flag booleano que representa si el mensaje es un ACK o no.
- ~Y~: es el flag booleano que representa si el mensaje es SYN o no.
- ~F~: es el flag booleano que representa si el mensaje es FIN o no.
- ~Unused~: es una porción de bits que no se usa y queda como padding para completar el tamaño de un short unsigned int (2 bytes).
- ~Port~: el puerto con el que el receptor del mensaje debe comunicarse, se usa para el cambio de puerto.
- ~Payload length~: unsigned int (4 bytes) que representa el largo de la data que contiene el paquete.
- ~Sequence number~: unsigned int (4 bytes) que representa el número de secuencia del paquete.
- ~Acknowledge number~: unsigned int (4 bytes) que representa el número de acknowledge, usado principalmente para saber cuál fue el último paquete que se recibió.
- ~Data~: información binaria (bytes) que son los datos a transportar.

El header tiene un tamaño de 16 bytes. \\

*Tamaño máximo de payload* \\

El tamaño se determina análogamente a SAW, sólo que esta vez se le resta el tamaño de header del protocolo (16 bytes). Quedando así un payload máximo de 1416 bytes.


*** Ciclo de Vida de Upload

#+BEGIN_SRC plantuml :file docs/imgs/gbn_upload.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

group ‎  [Handshake]

Client ->(10) Server : [SYN]\nseq=0, ack=0
Server ->(10) Client : [SYN], [ACK]\nseq=0, ack=0

Client ->(10) Server : [ACK]\nseq=1, ack=1\n data=2 (op_code)
Server ->(10) Client : [ACK]\nseq=1, ack=1

else Configuration

Client ->(10) Server : seq=2, ack=2\n data=report.pdf
Server ->(10) Client : [ACK]\nseq=2, ack=2

Client ->(10) Server : seq=3, ack=3\n data=3000
Server ->(10) Client : [ACK]\nseq=3, ack=3

else File transfer

Client ->(10) Server : seq=4, ack=4\npayload_length=1416\n data=101110...
Client ->(10) Server : seq=5, ack=4\npayload_length=1416\n data=101110...

Server ->(10) Client : [ACK]\nseq=4, ack=4
Server ->(10) Client : [ACK]\nseq=5, ack=5

else Closing handshake

Client ->(10) Server : [FIN]\nseq=6, ack=5\npayload_length=168\n data=101110...

Server ->(10) Client : [ACK]\nseq=6, ack=6
Server ->(10) Client : [FIN]\nseq=6, ack=6

Client ->(10) Server : [ACK]\nseq=7, ack=6

end

caption \nGo-Back-N protocol with window of\n 2 packets. Client uploads file \n(report.pdf of size 3000 bytes) to server

@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.65\textwidth
#+RESULTS:
[[file:docs/imgs/gbn_upload.png]]

*** Analisis del Ciclo de Vida de Upload de una transferencia con Go-Back-N

Se observa el comportamiento de una transferencia de archivos con una ventana de tamaño 2. En este caso, el cliente sube un archivo (report.pdf) de 3000 bytes al servidor.

**** Establecimiento de la conexión (Handshake):

    El cliente inicia la conexión enviando un paquete con el flag ~SYN~, con ~seq=0~ y ~ack=0~.

    El servidor responde con un paquete con flags ~SYN~ y ~ACK~, manteniendo los mismos valores de seq y ack.

    El cliente confirma la recepción enviando un paquete ~ACK~ con ~seq=1~ y ~ack=1~, incluyendo en datos la configuración del código de operación (en este caso de subida) ~data=2~ (op_code).

    El servidor responde con un ~ACK~ para confirmar la recepción del mensaje de configuración (~seq=1~, ~ack=1~).

**** Configuración:

    El cliente envía un paquete con ~seq=2~, ~ack=2~ y ~data=report.pdf~, indicando el nombre del archivo a subir.

    El servidor responde con un paquete ~ACK~ (~seq=2~, ~ack=2~) para confirmar la petición.

    El cliente envía un paquete con ~seq=3~, ~ack=3~ y ~data=3000~, informando el tamaño total del archivo en bytes.

    El servidor confirma la recepción de esta información con otro ~ACK~ (~seq=3~, ~ack=3~).

**** Transferencia del archivo:

    El cliente envía el primer chunk de datos con ~seq=4~, ~ack=4~, ~payload_length=1416~ y ~data=101110~….

    A continuación, envía el segundo chunk con ~seq=5~, ~ack=4~, ~payload_length=1416~ y ~data=101110~….

    El servidor confirma la recepción del primer chunk enviando un ~ACK~ (~seq=4~, ~ack=4~).

    Luego, confirma el segundo chunk con otro ~ACK~ (~seq=5~, ~ack=5~).

**** Cierre de la conexión (Closing handshake):

    El cliente inicia el cierre enviando un paquete ~FIN~ con ~seq=6~, ~ack=5~, ~payload_length=168~ y ~data=101110~….

    El servidor responde con un ~ACK~ final (~seq=6~, ~ack=6~).

    El servidor envía a su vez un paquete ~FIN~ (~seq=6~, ~ack=6~) para cerrar su lado de la comunicación.

    Finalmente, el cliente completa el cierre con un último ~ACK~ (~seq=7~, ~ack=6~).

*** Ciclo de Vida de Download

#+BEGIN_SRC plantuml :file docs/imgs/gbn_download.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

group [Handshake]

Client ->(10) Server : [SYN]\nseq=0, ack=0
Server ->(10) Client : [SYN], [ACK]\nseq=0, ack=0

Client ->(10) Server : [ACK]\nseq=1, ack=1\n data=1 (op_code)
Server ->(10) Client : [ACK]\nseq=1, ack=1

else Configuration

Client ->(10) Server : seq=2, ack=2\n data=report.pdf
Server ->(10) Client : [ACK]\nseq=2, ack=2\npayload_length=1416\n data=101110...
Client ->(10) Server : [ACK]\nseq=2, ack=2

else File transfer

Server ->(10) Client : seq=3, ack=2\npayload_length=1416\n data=101110...
Server ->(10) Client : [FIN]\nseq=4, ack=2\npayload_length=168\n data=101110...

Client ->(10) Server : [ACK]\nseq=3, ack=3
Client ->(10) Server : [ACK]\nseq=4, ack=4

else Closing handshake

Client ->(10) Server : [FIN]\nseq=4, ack=4
Server ->(10) Client : [ACK]\nseq=5, ack=5

end

caption \nGo-Back-N protocol with window of\n 2 packets. Client downloads file \n(report.pdf of size 3000 bytes) from server
@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.7\textwidth
#+RESULTS:
[[file:docs/imgs/gbn_download.png]]

*** Análisis del Ciclo de Vida de Download de una transferencia con Go-Back-N

Se observa el comportamiento de una transferencia de archivos con una ventana de tamaño 2. En
este caso, el cliente descarga un archivo (`report.pdf`) de 3000 bytes desde el servidor.

**** Establecimiento de la conexión (Handshake):
- El cliente inicia la conexión enviando un paquete con el flag ~SYN~, con ~seq=0~ y ~ack=0~.
- El servidor responde con un paquete con flags ~SYN~ y ~ACK~ manteniendo los mismos valores de ~seq~ y ~ack~.
- El cliente confirma la recepción enviando un paquete ~ACK~ con ~seq=1~ y ~ack=1~, incluyendo en datos la configuración del codigo de operacion (en este caso de descarga) ~data=1 (op_code)~.
- El servidor responde con un ~ACK~ para confirmar la recepción del mensaje de configuración.

**** Configuración:
- El cliente envía un paquete con ~seq=2~, ~ack=2~ y ~data=report.pdf~, indicando el nombre del archivo a descargar.
- El servidor responde con un paquete de datos con ~seq=2~, ~ack=2~, una ~size~ de 1416 bytes y los primeros bits del archivo.
- El cliente confirma la recepción con un ~ACK~ correspondiente.

**** Transferencia del archivo:
- El servidor envía el segundo ~chunk~ de datos (~seq=3~, ~ack=2~), también de 1416 bytes.
- Posteriormente, se envía un paquete con el flag ~FIN~ (~seq=4~, ~ack=2~, ~payload_length=168~), marcando el fin de la transferencia.
- El cliente responde con dos ~ACK~, uno para cada paquete recibido correctamente: ~seq=3, ack=3~ y ~seq=4, ack=4~.

**** Cierre de la conexión (Closing handshake):
- El cliente envía un ~FIN~ para finalizar su lado de la comunicación (~seq=4, ack=4~).
- El servidor responde con un ~ACK~ final (~seq=5, ack=5~), completando el cierre de la conexión de manera ordenada.

* Pruebas

Se presentan capturas de diferentes casos de uso de la aplicación.

** Casos de error

- Protocol Mismatch

\noindent \includegraphics[width=\textwidth]{docs/imgs/protocol_mismatch.png}
\captionof{figure}{Ejemplo de protocol mismatch.}

En caso de que un cliente intente conectarse con un servidor utilizando un protocolo diferente al suyo, el servidor lo rechazará. En la imagen se puede observar un ejemplo en el que un servidor que utiliza Stop & Wait rechaza a un cliente que hace una petición con Go Back N.

- Archivo ya existente

\noindent \includegraphics[width=\textwidth]{docs/imgs/file_already_exists.png}
\captionof{figure}{Ejemplo de upload de un archivo que ya existe en el servidor.}

Para ambos protocolos, si el cliente intenta subir un archivo que el servidor ya tiene, se rechaza.

- Descarga de un archivo que no existe

\noindent \includegraphics[width=\textwidth]{docs/imgs2/error_file_doesnt_exist.png}
\captionof{figure}{Ejemplo de intento de descarga de un archivo que no existe.}

Para ambos protocolos, si el cliente intenta descargar un archivo que el servidor no posee, se rechaza.

** Stop & Wait

Para mostrar el funcionamiento de Stop & Wait, mostraremos las capturas de las operaciones upload y download de un archivo pequeño de 5kB a modo de ejemplo. Primero sin pérdida de paquetes, y luego con una pérdida del 10% utilizando mininet.

*** Stop & Wait sin pérdida de paquetes

- Upload

\noindent \includegraphics[width=\textwidth]{docs/imgs/saw_upload.png}
\captionof{figure}{Captura de los logs de Upload con Stop and Wait.}


\noindent \includegraphics[width=\textwidth]{docs/imgs/saw_upload_wireshark.png}
\captionof{figure}{Captura de wireshark de Upload con Stop and Wait.}

- Download

\noindent \includegraphics[width=\textwidth]{docs/imgs/saw_download.png}
\captionof{figure}{Captura de los logs de Download con Stop and Wait.}

\noindent \includegraphics[width=\textwidth]{docs/imgs/saw_download_wireshark.png}
\captionof{figure}{Captura de wireshark de Download con Stop and Wait.}

*** Stop & Wait con pérdida de paquetes del 10%

- Upload

\noindent \includegraphics[width=\textwidth]{docs/imgs2/saw_10l_up.png}
\captionof{figure}{Captura de los logs de Upload con Stop and Wait con pérdida del 10 por ciento.}


\noindent \includegraphics[width=\textwidth]{docs/imgs2/saw_10l_up_ws.png}
\captionof{figure}{Captura de wireshark de Upload con Stop and Wait con pérdida del 10 por ciento.}

- Download

\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_up.png}
\captionof{figure}{Captura de los logs de Download con Stop and Wait con pérdida del 10 por ciento.}

\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_up_ws.png}
\captionof{figure}{Captura de wireshark de Download con Stop and Wait con pérdida del 10 por ciento.}

** Go Back N

Para mostrar el funcionamiento de Go Back N, mostraremos las capturas de las operaciones upload y download del mismo archivo de 5kB. Para este caso, mostraremos únicamente el caso con pérdida de paquetes, ya que el escenario con pérdida resulta muy similar al de Stop & Wait debido a que la ventana que utilizamos es mayor a la cantidad de paquetes que posee este archivo.

- Upload

\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_up.png}
\captionof{figure}{Captura de los logs de Upload con Go Back N.}


\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_up_ws.png}
\captionof{figure}{Captura de wireshark de Upload con Go Back N.}

- Download

\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_down.png}
\captionof{figure}{Captura de los logs de Download con Go Back N.}

\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_down_ws.png}
\captionof{figure}{Captura de wireshark de Download con Go Back N.}

* Preguntas a Responder
** Describa la arquitectura Cliente-Servidor.
La arquitectura Cliente-Servidor es una de dos arquitecturas más comunes. En esta arquitectura hay un /host/ (/end system/) llamado /server/ que esta siempre encendido que pasivamente escucha /requests/ de otros /hosts/ llamados /clients/ que son agentes activos que inician la comunicación con el /server/.

Un ejemplo de esta arquitectura es una aplicacion Web donde hay un /Web server/ que escucha /requests/ de navegadores web. El navegador web es el cliente que inicia la comunicación y el /Web server/ es el servidor que responde a los /requests/. Estos mensajes tienen el formato de Capa de Aplicación HTTP.

*** Caracteristicas
 - Los clientes son agentes activos que inician la comunicación.
 - Los clientes no se comunican entre si.
 - Los clientes no necesitan estar encendidos todo el tiempo ni tener una IP fija.
 - Los servidores son pasivos y siempre están encendidos.
 - Los servidores *deben* tener una IP fija bien conocida (/well-known IP address/) que se puede resolver con un nombre de dominio DNS (/domain name/).
 - Los servidores pueden tener múltiples clientes conectados al mismo tiempo.

*** Ventajas
 - Diseño simple usando protocolos sin estado como HTTP donde el servidor no
   necesita mantener informacion sobre clientes ya que se puede guardar
   informacion del cliente en /cookies/ del cliente y estos se transmitidos en
   /headers/ HTTP.
 - Puede soportar un gran numero de clientes.

*** Desventajas
 - Un solo punto de falla. Si el servidor se cae, el servicio se cae.
 - El servidor debe estar encendido todo el tiempo.
 - Gran costo para escalar, ya que a medida de que el servicio tiene mas
   usuarios, el servidor debe tambien aumentar su capacidad de procesar mas
   clientes.

** ¿Cuál es la función de un protocolo de capa de aplicación?

Un protocolo de capa de aplicación especifica cómo los procesos de una aplicación, que se ejecutan en diferentes sistemas finales, intercambian mensajes entre sí. Este tipo de protocolo define:

- Los tipos de mensajes que se envían, como mensajes de solicitud y de respuesta.

- La sintaxis de los mensajes, es decir, la estructura de los campos dentro de cada mensaje y cómo se separan o identifican esos campos.

- La semántica de los campos, indicando qué significa la información contenida en cada uno.

- Las reglas de comunicación, que establecen cuándo un proceso debe enviar un mensaje y cómo debe reaccionar al recibir uno.

En resumen, los protocolos de capa de aplicación aseguran que las aplicaciones puedan comunicarse correctamente y coordinarse en la red, haciendo posible servicios como el correo electrónico, la web o la transferencia de archivos.

** Detalle el protocolo de aplicación desarrollado en este trabajo.

** La capa de transporte del stack TCP/IP ofrece dos protocolos: TCP y UDP.

*** ¿Qué servicios proveen dichos protocolos?

Ambos protocolos proveen los siguientes servicios:

- *Multiplexación/Demultiplexación*: son los mecanismos que permiten extender el servicio de entrega de IP entre dos end systems a un servicio de entrega entre dos procesos que se ejecutan en esos sistemas. Dichos mecanismos permiten identificar a qué proceso pertenece cada ssegmento recibido.
- *Chequeo de integridad*: se verifica que no haya errores en los datos mediante un campo de checksum en los headers de ambos protocolos.

UDP no realiza ninguna otra función extra. Por lo tanto, su servicio es:
- *No confiable*: no garantiza que la entrega de los paquetes sea exitosa, ni tampoco que lleguen en orden.
- *Sin conexión*: cada paquete datagrama se envía de manera independiente, sin garantías de que el receptor esté listo o incluso disponible.

Por su parte, TCP ofrece las siguientes funcionalidades adicionales:
- *Orientado a la conexión*: antes de que un proceso de aplicación pueda comenzar a enviar datos a otro, ambos procesos deben comunicarse entre sí; es decir, deben enviarse algunos segmentos preliminares para establecer los parámetros de la transferencia de datos subsiguiente. Se trata de una conexión lógica con un estado en común que reside en TCP de los hosts.
- *Transferencia de datos confiable*: garantiza la entrega, el orden y la no corrupción de los datos. Esto lo logra mediante timers, numeros de secuencia y ACKs (flags que indican que un paquete fue entregado correctamente).
- *Control de congestión*: festiona que no se saturen los enlaces. Es más bien un servicio para la red.
- *Control de flujo*: para eliminar la posibilidad de que el remitente desborde el búfer del receptor. Hace coincidir la velocidad a la que el remitente envía con la velocidad a la que la aplicación receptora lee.

*** ¿Cuáles son sus características?

Algunas de las características de UDP son las siguientes:
- *Pequeño overhead de header por paquete*: UDP posee un header pequeño (8 bytes) en comparación con TCP (20 bytes)
- *Sin estado de conexión*: UDP no mantiene un estado de conexión en los end systems, por lo que no rastrea ningún parámetro. Por esta razón, un servidor dedicado a una aplicación específica generalmente puede admitir muchos más clientes activos cuando la aplicación se ejecuta mediante UDP en lugar de TCP.
- *Sin retraso por conexión*: UDP no induce ningún retraso para establecer una conexión, a diferencia de TCP que posee un handshake de tres pasos.

Por su parte, TCP posee las siguientes características:

- *Full-duplex*: dada una conexión TCP entre dos hosts, digamos A y B, la información puede fluir de A a B al mismo tiempo que fluye información de B a A.
- *Conexión point-to-point*: la conexión de TCP únicamente se puede establecer entre un único remitente y un único receptor, no admite multicasting.
- *Three-Way Handshake*: para establecer la conexión mencionada anteriormente se realiza un procedimiento donde se envían tres segmentos.

*** ¿Cuando es apropiado utilizar cada uno?

Ninguno de estos protocolos es mejor que el otro. Para decidir cuál de ellos utilizar, se deben tener en cuenta las necesidades de la aplicación.
Debido a las características mencionadas anteriormente, UDP resulta más apropiado para aplicaciones que requieran mayor velocidad sin que sea tan sensible a algunas pérdidas de paquetes, por ejemplo plataformas de streaming, y si se tiene un servidor dedicado a una aplicación específica que necesita poder admitir muchos más clientes activos.
Por otro lado, TCP es más ventajoso para las aplicaciones que necesitan un transporte confiable de los datos. Algunos ejemplos son el email y la web.
* Dificultades Encontradas
* Conclusión
* Anexo: Fragmentacion IPv4
** Enunciado :noexport:
El siguiente ejercicio se plantea como objetivo la comprensión y la puesta en
práctica de los conceptos y herramientas necesarias para la comprobación del
proceso de fragmentación en IPv4. Para lograr este objetivo, se deberá crear
una red virtual que contenga la topología propuesta y se deberá generar tráfico
para poder analizar el comportamiento del protocolo IPv4:

 - Utilizando mininet. se pide armar una topología lineal formada por dos hosts conectados a traves de 3 switches.
 - Reducir el MTU de alguna interfaz del switch central. Configurar un packet loss en una interfaz del switch conectada
 - al segundo host.
 - Generar tráfico UDP/TCP utilizando iperf. Configurar el tamaño de los paquetes de manera tal que se produzca el
 - proceso de fragmentación.
 - Capturar el tráfico utilizando wireshark.
 - Analizar el tráfico generado en la topología y comprobar empíricamente los siguientes fenómenos:
 - Proceso de fragmentación
 - Funcionamiento de TCP ante la pérdida de un fragmento
 - Funcionamiento de UDP ante la pérdida de un fragmento
 - Aumento de tráfico al reducirse el MTU mínimo de la red.

** Consideraciones iniciales

Se propuso inicialmente una red de topología lineal que una a un host servidor, tres switches conectados en serie y un host cliente donde haya pérdida de paquetes en el enlace próximo al host receptor y que el switch central tenga la capacidad de fragmentar paquetes IPv4. Sin embargo, los switches en mininet no tienen la capacidad de fragmentar paquetes, por lo que al forzar fragmentación (es decir, reducir el MTU de alguna de sus interfaces) causaría una pérdida total de todo paquete de tamaño mayor al MTU.

La solución propuesta fue sustituir ese switch central por un "router" central, un tipo de nodo de mininet similar a los hosts pero que además cuenta con la capacidad de hacer forwarding de paquetes IPv4. Conceptualmente un switch, al ser un elemento de Link Layer, no debe tener la capacidad de fragmentar paquetes de otra capa de red.

Otro de los conflictos presentados es la comunicación bidireccional. Reducir el MTU de alguna interfaz de un router implica que se reduce sobre el enlace de esta interfaz. Y si este enlace está conectado a un router y a un switch, la comunicación andará bien en sentido router->switch pero se perderán los paquetes en el sentido switch->router. Por lo que si se desea una comunicación bidireccional en la red y se requiere reducir el MTU de alguna interfaz de la topología esta NO debe estar vinculada a un switch, de lo contrario se perderá todo paquete que exceda el MTU reducido. Dicho esto, se decidió arbitrariamente que basta con tener comunicación unidireccional (C->S) para poder provocar el fenómeno de fragmentación de paquetes IPv4.

** Análisis
*** Topología
#+ATTR_LATEX: :width 0.5\textwidth
[[file:docs/frag_imgs/linear_ends_fragmentation_item.png]]

Se define una pérdida de 20% de paquetes sobre el enlace próximo al servidor, un MTU de 800 en la interfaz saliente del router (s2-eth0) y un tamaño de paquetes de 1000B (arbitrariamente, basta con que sea ligeramente superior al MTU reducido) para estudiar este fenómeno.

*** Proceso de fragmentación

Habiendo definido la red como se mencionó anteriormente, basta generar tráfico de cliente a servidor usando iperf y capturar los paquetes recibidos y enviados por el router (s2) con Wireshark para estudiar este fenómeno. Por ejemplo:

Paquetes capturados en interfaz de entrada del router (s2-eth1):
No.	Time	Source	Destination	Protocol	Length	Info
...
23	1.971521	10.0.1.1	10.0.0.1	TCP	74	54360 → 5001 [SYN] Seq=0 Win=43000 Len=0 MSS=1000 SACK_PERM TSval=2993150612 TSecr=0 WS=512
24	1.991994	10.0.0.1	10.0.1.1	TCP	74	5001 → 54360 [SYN, ACK] Seq=0 Ack=1 Win=43440 Len=0 MSS=1460 SACK_PERM TSval=2142019792 TSecr=2993150612 WS=512
25	1.995183	10.0.1.1	10.0.0.1	TCP	66	54360 → 5001 [ACK] Seq=1 Ack=1 Win=43008 Len=0 TSval=2993150645 TSecr=2142019792
26	1.995677	10.0.1.1	10.0.0.1	TCP	126	54360 → 5001 [PSH, ACK] Seq=1 Ack=1 Win=43008 Len=60 TSval=2993150646 TSecr=2142019792
27	1.995841	10.0.0.1	10.0.1.1	TCP	66	5001 → 54360 [ACK] Seq=1 Ack=61 Win=43520 Len=0 TSval=2142019813 TSecr=2993150646
28	1.996044	10.0.0.1	10.0.1.1	TCP	94	5001 → 54360 [PSH, ACK] Seq=1 Ack=61 Win=43520 Len=28 TSval=2142019813 TSecr=2993150646
29	1.996235	10.0.1.1	10.0.0.1	TCP	2042	54360 → 5001 [PSH, ACK] Seq=61 Ack=1 Win=43008 Len=1976 TSval=2993150646 TSecr=2142019792
30	1.996274	10.0.1.1	10.0.0.1	TCP	2042	54360 → 5001 [PSH, ACK] Seq=2037 Ack=1 Win=43008 Len=1976 TSval=2993150646 TSecr=2142019792
...

Paquetes capturados en interfaz de salida del router (s2-eth0):
No.	Time	Source	Destination	Protocol	Length	Info
...
16	1.893458	10.0.1.1	10.0.0.1	TCP	74	54360 → 5001 [SYN] Seq=0 Win=43000 Len=0 MSS=1000 SACK_PERM TSval=2993150612 TSecr=0 WS=512
17	1.911142	10.0.0.1	10.0.1.1	TCP	74	5001 → 54360 [SYN, ACK] Seq=0 Ack=1 Win=43440 Len=0 MSS=1460 SACK_PERM TSval=2142019792 TSecr=2993150612 WS=512
18	1.914359	10.0.1.1	10.0.0.1	TCP	66	54360 → 5001 [ACK] Seq=1 Ack=1 Win=43008 Len=0 TSval=2993150645 TSecr=2142019792
19	1.914855	10.0.1.1	10.0.0.1	TCP	126	54360 → 5001 [PSH, ACK] Seq=1 Ack=1 Win=43008 Len=60 TSval=2993150646 TSecr=2142019792
20	1.915001	10.0.0.1	10.0.1.1	TCP	66	5001 → 54360 [ACK] Seq=1 Ack=61 Win=43520 Len=0 TSval=2142019813 TSecr=2993150646
21	1.915201	10.0.0.1	10.0.1.1	TCP	94	5001 → 54360 [PSH, ACK] Seq=1 Ack=61 Win=43520 Len=28 TSval=2142019813 TSecr=2993150646
22	1.915411	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=TCP 6, off=0, ID=6401) [Reassembled in #23]
23	1.915413	10.0.1.1	10.0.0.1	TCP	278	54360 → 5001 [ACK] Seq=61 Ack=1 Win=43008 Len=988 TSval=2993150646 TSecr=2142019792
24	1.915415	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=TCP 6, off=0, ID=6402) [Reassembled in #25]
25	1.915416	10.0.1.1	10.0.0.1	TCP	278	54360 → 5001 [PSH, ACK] Seq=1049 Ack=1 Win=43008 Len=988 TSval=2993150646 TSecr=2142019792
26	1.915444	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=TCP 6, off=0, ID=6403) [Reassembled in #27]
27	1.915445	10.0.1.1	10.0.0.1	TCP	278	54360 → 5001 [ACK] Seq=2037 Ack=1 Win=43008 Len=988 TSval=2993150646 TSecr=2142019792
28	1.915447	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=TCP 6, off=0, ID=6404) [Reassembled in #29]
29	1.915448	10.0.1.1	10.0.0.1	TCP	278	54360 → 5001 [PSH, ACK] Seq=3025 Ack=1 Win=43008 Len=988 TSval=2993150646 TSecr=2142019792
30	1.915467	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=TCP 6, off=0, ID=6405) [Reassembled in #31]
...

Se observa que tras establecer la comunicación inicial, se envían paquetes de un tamaño que lleva a forzar que el router fragmente los paquetes TCP recibidos en varios paquetes TCP/IPv4, esto según que tan grande sea la relación tamaño de paquete/MTU del enlace. Se logra identificar que paquete se fragmentó según los números de secuencia que muestra Wireshark en su columna de información, y para paquetes que no tienen número de secuencia coincidente indica que se requirió fragmentar más de una vez.

Si se hace una suma del tamaño de los fragmentos hasta que coincidan paquetes de ambas tablas, se observa como el router termina enviando más bytes de los que recibió. Esto debido a que el reensamblado de paquetes se produce incluyendo encabezados de todas las capas de red.

*** Funcionamiento de TCP ante la pérdida de un fragmento
TCP es un protocolo de transporte que maneja la retransmisión de datos tras pérdida y detección a partir de ACKs duplicados. Este fenómeno es muy simple de visualizar en Wireshark, donde se señala en la columna de información cuando un paquete corresponde a información retransmitida (Retransmission/Fast Retransmission)

No.	Time	Source	Destination	Protocol	Length	Info
...
42	2.002269	10.0.1.1	10.0.0.1	TCP	2042	54360 → 5001 [PSH, ACK] Seq=16857 Ack=1 Win=43008 Len=1976 TSval=2993150652 TSecr=2142019792
41	2.002234	10.0.1.1	10.0.0.1	TCP	2042	54360 → 5001 [PSH, ACK] Seq=14881 Ack=1 Win=43008 Len=1976 TSval=2993150652 TSecr=2142019792
43	2.002311	10.0.1.1	10.0.0.1	TCP	1054	[TCP Fast Retransmission] 54360 → 5001 [ACK] Seq=2037 Ack=1 Win=43008 Len=988 TSval=2993150652 TSecr=2142019792
44	2.002843	10.0.0.1	10.0.1.1	TCP	86	[TCP Dup ACK 34#4] 5001 → 54360 [ACK] Seq=29 Ack=2037 Win=41984 Len=0 TSval=2142019818 TSecr=2993150646 SLE=5001 SRE=8953 SLE=3025 SRE=4013
45	2.002884	10.0.1.1	10.0.0.1	TCP	1054	[TCP Retransmission] 54360 → 5001 [ACK] Seq=4013 Ack=1 Win=43008 Len=988 TSval=2993150653 TSecr=2142019792
46	2.003232	10.0.1.1	10.0.0.1	TCP	66	54360 → 5001 [ACK] Seq=18833 Ack=29 Win=43008 Len=0 TSval=2993150653 TSecr=2142019792
47	2.005101	10.0.0.1	10.0.1.1	TCP	86	[TCP Dup ACK 34#5] 5001 → 54360 [ACK] Seq=29 Ack=2037 Win=41984 Len=0 TSval=2142019821 TSecr=2993150646 SLE=5001 SRE=9941 SLE=3025 SRE=4013
48	2.005135	10.0.1.1	10.0.0.1	TCP	1054	54360 → 5001 [ACK] Seq=18833 Ack=29 Win=43008 Len=988 TSval=2993150655 TSecr=2142019821
49	2.005341	10.0.0.1	10.0.1.1	TCP	94	[TCP Dup ACK 34#6] 5001 → 54360 [ACK] Seq=29 Ack=2037 Win=41984 Len=0 TSval=2142019822 TSecr=2993150646 SLE=5001 SRE=11917 SLE=18833 SRE=19821 SLE=3025 SRE=4013
50	2.005364	10.0.1.1	10.0.0.1	TCP	1054	[TCP Fast Retransmission] 54360 → 5001 [ACK] Seq=2037 Ack=29 Win=43008 Len=988 TSval=2993150655 TSecr=2142019822
51	2.005371	10.0.1.1	10.0.0.1	TCP	1054	[TCP Retransmission] 54360 → 5001 [ACK] Seq=4013 Ack=29 Win=43008 Len=988 TSval=2993150655 TSecr=2142019822
52	2.005376	10.0.1.1	10.0.0.1	TCP	1054	[TCP Retransmission] 54360 → 5001 [ACK] Seq=11917 Ack=29 Win=43008 Len=988 TSval=2993150655 TSecr=2142019822
53	2.005382	10.0.1.1	10.0.0.1	TCP	1054	[TCP Retransmission] 54360 → 5001 [ACK] Seq=12905 Ack=29 Win=43008 Len=988 TSval=2993150655 TSecr=2142019822
54	2.005429	10.0.0.1	10.0.1.1	TCP	94	5001 → 54360 [ACK] Seq=29 Ack=4013 Win=40448 Len=0 TSval=2142019822 TSecr=2993150655 SLE=12905 SRE=13893 SLE=5001 SRE=11917 SLE=18833 SRE=19821
...

Este mecanismo garantiza que no se pierden datos durante la comunicación en el caso de pérdida de paquetes. Para esta experiencia, como se fuerza la fragmentación de paquetes IPv4 antes del enlace con pérdida de paquetes, en su mayoría lo que se retransmite son fragmentos IPv4 perdidos, esto salvo que se pierdan datos referentes a la conexión como los ACKs de handshake/cierre de conexión u otros paquetes como la actualización de ventanas de transmisión. Dicho esto, el fenómeno de retransmisión de paquetes es el mismo para todo tipo de paquete del protocolo.

Capturando el output del comando iperf (ejecutado durante 3 segundos) se puede observar el resultado final de la comunicación en cliente y servidor:

Cliente:
#+ATTR_LATEX: :width 0.5\textwidth
[[file:docs/frag_imgs/iperf_client_tcp.png]]

Servidor:
#+ATTR_LATEX: :width 0.5\textwidth
[[file:docs/frag_imgs/iperf_server_tcp.png]]

*** Funcionamiento de UDP ante la pérdida de un fragmento

TCP no es un protocolo orientado a la transferencia confiable de datos, por lo que NO cuenta con ningún mecanismo tras pérdida de paquetes, solamente envía sin garantía de recepción.

En estas capturas de Wireshark se evidencia como ocurre el fenómeno de fragmentación, donde al solo fragmentar en 2 un paquete UDP en Wireshark se capturará cerca del doble de paquetes en cada interfaz (o más según la relación tamaño/MTU):

Paquetes capturados en interfaz de entrada del router (s2-eth1):
No.	Time	Source	Destination	Protocol	Length	Info
...
9	1.125290	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
10	1.126623	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
12	1.126743	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
11	1.126713	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
13	1.126777	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
...

Paquetes capturados en interfaz de salida del router (s2-eth0):
...
No.	Time	Source	Destination	Protocol	Length	Info
14	1.125302	10.0.1.1	10.0.0.1	UDP	266	55090 → 5001 Len=1000
15	1.126628	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=UDP 17, off=0, ID=bd6e) [Reassembled in #16]
16	1.126633	10.0.1.1	10.0.0.1	UDP	266	55090 → 5001 Len=1000
17	1.126698	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=UDP 17, off=0, ID=bd6f) [Reassembled in #18]
13	1.125298	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=UDP 17, off=0, ID=bd6d) [Reassembled in #14]
18	1.126699	10.0.1.1	10.0.0.1	UDP	266	55090 → 5001 Len=1000
19	1.126727	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=UDP 17, off=0, ID=bd70) [Reassembled in #20]
20	1.126729	10.0.1.1	10.0.0.1	UDP	266	55090 → 5001 Len=1000
21	1.126763	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=UDP 17, off=0, ID=bd71) [Reassembled in #22]
22	1.126765	10.0.1.1	10.0.0.1	UDP	266	55090 → 5001 Len=1000
...

Sin embargo, al haber pérdida de paquetes cercano al servidor, esta no puede observarse capturando sobre el router sino sobre el servidor, donde se observaría que tantos paquetes se pierden a partir de que tantos envió el cliente. Otra forma más sencilla de observar este fenómeno es con el output del comando iperf ejecutado sobre UDP, donde explícitamente señala que cantidad de paquetes se perdieron.

Cliente:
#+ATTR_LATEX: :width 0.5\textwidth
[[file:docs/frag_imgs/iperf_client_udp.png]]

Servidor:
#+ATTR_LATEX: :width 0.5\textwidth
[[file:docs/frag_imgs/iperf_server_udp.png]]

Donde se observa una pérdida en torno al 20% definido inicialmente.

*** Aumento de tráfico al reducirse el MTU mínimo de la red.

Por último, el fenómeno más sencillo de comprobar. Como se mencionó anteriormente, ya que el router fragmenta paquetes de ambos protocolos de transporte en función de su tamaño y el MTU de la interfaz de salida, siempre va a enviar más paquetes de los que recibe, por lo que se observa un aumento notorio del tráfico en la red. Para esta experiencia, se observa un aumento trabajando con UDP:

Paquetes capturados en interfaz de entrada del router (s2-eth1):
...
No.	Time	Source	Destination	Protocol	Length	Info
...
3762	4.119552	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
3763	4.120970	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
3764	4.121056	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
3765	4.134780	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
3766	4.140611	10.0.0.1	10.0.1.1	UDP	170	5001 → 55090 Len=128

Paquetes capturados en interfaz de salida del router (s2-eth0):
...
No.	Time	Source	Destination	Protocol	Length	Info
7519	4.121043	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=UDP 17, off=0, ID=cc13) [Reassembled in #7520]
7520	4.121046	10.0.1.1	10.0.0.1	UDP	266	55090 → 5001 Len=1000
7521	4.134785	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=UDP 17, off=0, ID=cc14) [Reassembled in #7522]
7522	4.134792	10.0.1.1	10.0.0.1	UDP	266	55090 → 5001 Len=1000
7523	4.140574	10.0.0.1	10.0.1.1	UDP	170	5001 → 55090 Len=128

Y se observa también un aumento en el tráfico de la red trabajando con TCP:

Paquetes capturados en interfaz de salida del router (s2-eth1):
No.	Time	Source	Destination	Protocol	Length	Info
...
495	9.978010	10.0.0.1	10.0.1.1	TCP	78	[TCP Window Update] 5001 → 54360 [ACK] Seq=29 Ack=227301 Win=531968 Len=0 TSval=2142027795 TSecr=2993158628 SLE=228289 SRE=229277
496	9.978020	10.0.1.1	10.0.0.1	TCP	1054	[TCP Retransmission] 54360 → 5001 [ACK] Seq=227301 Ack=29 Win=43008 Len=988 TSval=2993158628 TSecr=2142027795
497	9.985551	10.0.0.1	10.0.1.1	TCP	78	5001 → 54360 [FIN, ACK] Seq=29 Ack=227301 Win=531968 Len=0 TSval=2142027802 TSecr=2993158628 SLE=228289 SRE=229277
498	9.985578	10.0.1.1	10.0.0.1	TCP	66	54360 → 5001 [ACK] Seq=229277 Ack=30 Win=43008 Len=0 TSval=2993158635 TSecr=2142027802
499	10.551816	10.0.1.1	10.0.0.1	TCP	1054	[TCP Retransmission] 54360 → 5001 [ACK] Seq=227301 Ack=30 Win=43008 Len=988 TSval=2993159202 TSecr=2142027802

Paquetes capturados en interfaz de salida del router (s2-eth0):
No.	Time	Source	Destination	Protocol	Length	Info
...
820	9.897189	10.0.1.1	10.0.0.1	TCP	278	[TCP Retransmission] 54360 → 5001 [ACK] Seq=227301 Ack=29 Win=43008 Len=988 TSval=2993158628 TSecr=2142027795
821	9.904702	10.0.0.1	10.0.1.1	TCP	78	5001 → 54360 [FIN, ACK] Seq=29 Ack=227301 Win=531968 Len=0 TSval=2142027802 TSecr=2993158628 SLE=228289 SRE=229277
822	9.904745	10.0.1.1	10.0.0.1	TCP	66	54360 → 5001 [ACK] Seq=229277 Ack=30 Win=43008 Len=0 TSval=2993158635 TSecr=2142027802
823	10.471001	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=TCP 6, off=0, ID=6534) [Reassembled in #824]
824	10.471020	10.0.1.1	10.0.0.1	TCP	278	[TCP Retransmission] 54360 → 5001 [ACK] Seq=227301 Ack=30 Win=43008 Len=988 TSval=2993159202 TSecr=2142027802
