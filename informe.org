#+LANGUAGE: es
#+OPTIONS: toc:nil title:nil

#+LATEX_CLASS_OPTIONS: [titlepage,a4paper]
#+LATEX_HEADER_EXTRA: \hypersetup{colorlinks=true,linkcolor=black,urlcolor=blue,bookmarksopen=true}
#+LATEX_HEADER_EXTRA: \usepackage{a4wide}
#+LATEX_HEADER_EXTRA: \usepackage{bookmark}
#+LATEX_HEADER_EXTRA: \usepackage{fancyhdr}
#+LATEX_HEADER_EXTRA: \usepackage[spanish]{babel}
#+LATEX_HEADER_EXTRA: \usepackage[utf8]{inputenc}
#+LATEX_HEADER_EXTRA: \usepackage[T1]{fontenc}
#+LATEX_HEADER_EXTRA: \usepackage{graphicx}
#+LATEX_HEADER_EXTRA: \usepackage{float}
#+LATEX_HEADER_EXTRA: \usepackage{minted}
#+LATEX_HEADER_EXTRA: \usepackage{svg}
#+LATEX_HEADER_EXTRA: \usepackage{xcolor}
#+LATEX_HEADER_EXTRA: \pagestyle{fancy}
#+LATEX_HEADER_EXTRA: \fancyhf{}
#+LATEX_HEADER_EXTRA: \fancyhead[L]{TP1 - Grupo 2}
#+LATEX_HEADER_EXTRA: \fancyhead[R]{Redes - FIUBA}
#+LATEX_HEADER_EXTRA: \renewcommand{\headrulewidth}{0.4pt}
#+LATEX_HEADER_EXTRA: \fancyfoot[C]{\thepage}
#+LATEX_HEADER_EXTRA: \renewcommand{\footrulewidth}{0.4pt}
#+LATEX_HEADER_EXTRA: \usemintedstyle{stata-light}
#+LATEX_HEADER_EXTRA: \newminted{c}{bgcolor={rgb}{0.95,0.95,0.95}}
#+LATEX_HEADER_EXTRA: \usepackage{color}
#+LATEX_HEADER_EXTRA: \usepackage[utf8]{inputenc}
#+LATEX_HEADER_EXTRA: \usepackage{fancyvrb}
#+LATEX_HEADER_EXTRA: \fvset{framesep=1mm,fontfamily=courier,fontsize=\scriptsize,numbers=left,framerule=.3mm,numbersep=1mm}
#+LATEX_HEADER_EXTRA: \usepackage[nottoc]{tocbibind}
#+LATEX_HEADER_EXTRA: \usepackage{amsmath}
#+LATEX_HEADER_EXTRA: \usepackage{changepage}

#+NAME: setup
#+BEGIN_SRC emacs-lisp :results silent :exports none
  (setq org-latex-minted-options
    '(("bgcolor" "bg")))
#+END_SRC

#+BEGIN_EXPORT latex
\begin{titlepage}
    \hfill\includegraphics[width=6cm]{docs/imgs/logofiuba.jpg}
    \centering
    \vfill
    \Huge \textbf{Trabajo Práctico 1}
    \vskip2cm
    \Large [TA048] Redes \\
    Primer cuatrimestre de 2025\\
    \vfill
    \begin{tabular}{ | l | l | l | }
      \hline
      Alumno & Padron & Email \\ \hline
      AVALOS, Victoria & 108434 & vavalos@fi.uba.ar \\ \hline
      CASTRO MARTINEZ, Jose Ignacio & 106957 & jcastrom@fi.uba.ar \\ \hline
      CIPRIANO, Victor & 106593 & vcipriano@fi.uba.ar \\ \hline
      DEALBERA, Pablo Andres & 106858 & pdealbera@fi.uba.ar \\ \hline
      DIEM, Walter Gabriel & 105618 & wdiem@fi.uba.ar \\ \hline
    \end{tabular}
    \vfill
\end{titlepage}
\tableofcontents
\newpage
\definecolor{bg}{rgb}{0.95,0.95,0.95}
#+END_EXPORT

* Introduccion

* Hipótesis y suposiciones realizadas

- La carga/descarga no va a conservar la metadata del archivo. Es decir, si yo descargo un archivo, ese archivo va a tener metadata como si yo hubiera creado el archivo desde cero usando `touch archivo`.
- Si el cliente utiliza otro protocolo para comunicarse con el server, el server debe rechazar este pedido. (PROTOCOL MISSMATCH). El header tendra un campo dedicado a esto.
- El argumento de FILENAME sera opcional, en caso de no estar, se utiliza el nombre original del archivo.
- Por simplicidad, vamos a guardar todos los archivos en DIRPATH sin ningun nivel de subdirectorios.
- Por simplicidad, vamos a tener un tamaño maximo de 2GB para la subida y descarga de archivos.
- Los archivos en proceso de escritura se van a escribir en una ubicacion temporal para evitar que se corrompan en la ubicacion que el cliente pidio.
- Usar seek y bufferear para leer el archivo. Leer con slices del buffer.

* Implementacion
** Topología

#+ATTR_LATEX: :width 0.5\textwidth
[[file:docs/imgs/linear_ends_multiple_clients_with_loss.png]]

La topología es una red lineal con 1 host servidor conectado a 3 switches en serie cuyo ultimo switch esta conectado a n hosts clientes. El primer enlace (el conectado entre el servidor y el primero switch) tiene configurado un packet loss del 10\% configurado de forma simetrica 5% de cada lado del enlace.

** Especificación del protocolo Stop-and-Wait

*** General

**** Tamaño maximo de payload

El tamaño máximo de payload es el tamaño máximo de un datagrama UDP menos el tamaño de los headers de IP, UDP y SAW.

Como el MTU que usamos en mininet es 1500, el tamaño máximo de payload es:

\begin{align*}
  \text{HISTORICAL\_MTU} &= 1500 \\
  \text{MAX\_IP\_HEADER\_SIZE} &= 60 \\
  \text{UDP\_HEADER\_SIZE} &= 8 \\
  \text{SAW\_PROTOCOL\_HEADER\_SIZE} &= 6 \\
\end{align*}

\begin{align*}
\text{FILE\_CHUNK\_SIZE} = \text{HISTORICAL\_MTU} - \text{MAX\_IP\_HEADER\_SIZE} \\
                        -\ \text{UDP\_HEADER\_SIZE} - \text{SAW\_PROTOCOL\_HEADER\_SIZE}
\end{align*}

*** Handshake

#+BEGIN_SRC plantuml :file docs/imgs/connection-handshake.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

Client ->(10) Server : SYN, seq 0
Server ->(10) Client : SYN, ACK, seq 1
Client ->(10) Server : ACK, OP_CODE (piggybacked)
Server ->(10) Client : ACK
@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.5\textwidth
#+RESULTS:
[[file:docs/imgs/connection-handshake.png]]

La idea es usar este handshake para inicialización de recursos del servidor y check de protocolo. \\

Se usa la nomenclatura S para mencionar al servidor y C para el cliente.

_Mensajes para caso Download y caso Upload_:

1. C \rightarrow S: con flag SYN para declarar una solicitud de conexion y el protocolo

*Flujo normal (mismo protocolo)*:

2. [@2] S \rightarrow C: con flag de SYN y ACK para declarar que se acepta la conexión y el puerto donde se va a escuchar el resto.
3. C \rightarrow S: con flag ACK al mismo welcoming socket.

*Flujo de error (distinto protocolo)*:

2. [@2] S \rightarrow C: con flag FIN para denegar la conexión por usar un protocolo distinto.

Se hace una transferencia de puerto para que el welcoming socket se encargue solamente de establecer conexiones y el nuevo puerto maneje la transferencia de datos del archivo. El último ACK de parte del cliente asegura que se recibió el puerto donde se tiene que comunicar y es seguro hacer el cambio de socket.

*** Etapa de configuración y Transferencia

El cliente ya sabe que tiene que comunicarse con el nuevo puerto.

Se envia primero la configuracion para saber si la operacion es valida y tener en cuenta casos de error, y luego se hace la transferencia. \\

_Mensajes para caso Download y caso Upload_:

1. C \rightarrow S: se declara la operacion (OP), que puede ser download (0) o upload (1)
2. S \rightarrow C: ACK de la operacion (no falla)

_Continuación de mensajes para caso Download_:

3. [@3] Mensaje 3 C \rightarrow S: filename

*Flujo Normal*:

4. [@4] S \rightarrow C: ACK + comienzo de datos (piggybacked)
5. C \rightarrow S: ACK
6. S \rightarrow C: continuacion de datos

*Flujo de error (no existe un archivo con ese nombre)*:

4. [@4] S \rightarrow C: FIN, se termina la conexión

_Continuación de mensajes para caso Upload_:

3. [@3] C \rightarrow S: filename

*Flujo de error (ya existe un archivo con ese nombre)*:

4. [@4] S \rightarrow C: FIN, se termina la conexión

*Flujo normal*:

4. [@4] S \rightarrow C: ACK
5. C \rightarrow S: filesize

*Flujo de error (archivo es más grande que el tamaño máximo o [TODO] no hay más espacio en disco)*:

6. [@6] S \rightarrow C: FIN, se termina la conexión

*Flujo normal*:

6. [@6] S \rightarrow C: ACK
7. C \rightarrow S: comienzo de datos
8. S \rightarrow C: ACK
9. C \rightarrow S: continuacion de datos

*** Cierre

El flag FIN va piggybacked con la última data para que sea más eficiente. El receptor confirma con un ACK + FIN para que el emisor sepa que le llego la informacion, y por si este se pierde está el último ACK para confirmar el cierre de parte del emisor. \\

**** Mensajes para caso Download

#+BEGIN_SRC plantuml :file docs/imgs/download.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

Client ->(10) Server : Filename
Server ->(10) Client : ACK, Data Chunk 1 (piggybacked)
Client ->(10) Server : ACK of Data Chunk 1
Server ->(10) Client : Data Chunk 2
Client ->(10) Server : ACK of Data Chunk 2
Server ->(10) Client : ...
Client ->(10) Server : ...
Server ->(10) Client : FIN, Data Chunk n
Client ->(10) Server : FIN, ACK of Data Chunk n
@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.5\textwidth
#+RESULTS:
[[file:docs/imgs/download.png]]

1. S \rightarrow C: ultima data, va piggybacked el flag FIN
2. C \rightarrow S: ACK + FIN
3. S \rightarrow C: ACK

**** Mensajes para caso Upload:

#+BEGIN_SRC plantuml :file docs/imgs/upload.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

Client ->(10) Server : Filename
Server ->(10) Client : ACK
Client ->(10) Server : Filesize
Server ->(10) Client : ACK
Client ->(10) Server : Data
@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.5\textwidth
#+RESULTS:
[[file:docs/imgs/upload.png]]

1. C \rightarrow S: ultima data, va piggybacked el flag FIN
2. S \rightarrow C: ACK + FIN
3. C \rightarrow S: ACK

* Pruebas

\begin{adjustwidth}{-3cm}{-3cm}
\begin{center}
\begin{tabular}{rrrrlrlrlllrrl}
No & Time & Src & Dst & Proto & Len & Type & SEQ & ACK & SYN & FIN & SrcPort & DstPort\\[0pt]
\hline
1 & 0.000000000 & 10.0.1.1 & 10.0.0.1 & SAW & 48 & Stop-and-Wait & 0 & False & True & False & 52515 & 0\\[0pt]
2 & 0.000191297 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 0 & True & True & False & 41367 & 0\\[0pt]
3 & 0.002208402 & 10.0.1.1 & 10.0.0.1 & SAW & 50 & Stop-and-Wait & 1 & True & False & False & 52515 & 2\\[0pt]
4 & 0.002801150 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 1 & True & False & False & 41367 & 0\\[0pt]
5 & 0.004355272 & 10.0.1.1 & 10.0.0.1 & SAW & 53 & Stop-and-Wait & 0 & False & False & False & 52515 & 5\\[0pt]
6 & 0.004722710 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 0 & True & False & False & 41367 & 0\\[0pt]
7 & 0.005754904 & 10.0.1.1 & 10.0.0.1 & SAW & 52 & Stop-and-Wait & 1 & False & False & False & 52515 & 4\\[0pt]
8 & 0.005879502 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 1 & True & False & False & 41367 & 0\\[0pt]
9 & 0.006562696 & 10.0.1.1 & 10.0.0.1 & SAW & 1474 & Stop-and-Wait & 0 & False & False & False & 52515 & 1426\\[0pt]
10 & 0.006634214 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 0 & True & False & False & 41367 & 0\\[0pt]
11 & 0.006819155 & 10.0.1.1 & 10.0.0.1 & SAW & 1474 & Stop-and-Wait & 1 & False & False & False & 52515 & 1426\\[0pt]
12 & 0.006887880 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 1 & True & False & False & 41367 & 0\\[0pt]
\ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{}\ldots{}\\[0pt]
384 & 0.036747322 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 1 & True & False & False & 41367 & 0\\[0pt]
385 & 0.036806828 & 10.0.1.1 & 10.0.0.1 & SAW & 1474 & Stop-and-Wait & 0 & False & False & False & 52515 & 1426\\[0pt]
386 & 0.036860606 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 0 & True & False & False & 41367 & 0\\[0pt]
387 & 0.037000220 & 10.0.1.1 & 10.0.0.1 & SAW & 1474 & Stop-and-Wait & 1 & False & False & False & 52515 & 1426\\[0pt]
388 & 0.037084310 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 1 & True & False & False & 41367 & 0\\[0pt]
389 & 0.037217987 & 10.0.1.1 & 10.0.0.1 & SAW & 363 & Stop-and-Wait & 0 & False & False & True & 52515 & 315\\[0pt]
390 & 0.037459011 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 0 & True & False & False & 41367 & 0\\[0pt]
391 & 0.037511183 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 0 & False & False & True & 41367 & 0\\[0pt]
392 & 0.037580397 & 10.0.1.1 & 10.0.0.1 & SAW & 48 & Stop-and-Wait & 1 & True & False & False & 52515 & 0\\[0pt]
\end{tabular}
\end{center}
\end{adjustwidth}

* Preguntas a Responder
** Describa la arquitectura Cliente-Servidor.
La arquitectura Cliente-Servidor es una de dos arquitecturas más comunes. En esta arquitectura hay un /host/ (/end system/) llamado /server/ que esta siempre encendido que pasivamente escucha /requests/ de otros /hosts/ llamados /clients/ que son agentes activos que inician la comunicación con el /server/.

Un ejemplo de esta arquitectura es una aplicacion Web donde hay un /Web server/ que escucha /requests/ de navegadores web. El navegador web es el cliente que inicia la comunicación y el /Web server/ es el servidor que responde a los /requests/. Estos mensajes tienen el formato de Capa de Aplicación HTTP.

*** Caracteristicas
 - Los clientes son agentes activos que inician la comunicación.
 - Los clientes no se comunican entre si.
 - Los clientes no necesitan estar encendidos todo el tiempo ni tener una IP fija.
 - Los servidores son pasivos y siempre están encendidos.
 - Los servidores *deben* tener una IP fija bien conocida (/well-known IP address/) que se puede resolver con un nombre de dominio DNS (/domain name/).
 - Los servidores pueden tener múltiples clientes conectados al mismo tiempo.

*** Ventajas
 - Diseño simple usando protocolos sin estado como HTTP donde el servidor no
   necesita mantener informacion sobre clientes ya que se puede guardar
   informacion del cliente en /cookies/ del cliente y estos se transmitidos en
   /headers/ HTTP.
 - Puede soportar un gran numero de clientes.

*** Desventajas
 - Un solo punto de falla. Si el servidor se cae, el servicio se cae.
 - El servidor debe estar encendido todo el tiempo.
 - Gran costo para escalar, ya que a medida de que el servicio tiene mas
   usuarios, el servidor debe tambien aumentar su capacidad de procesar mas
   clientes.

** ¿Cuál es la función de un protocolo de capa de aplicación?

Un protocolo de capa de aplicación especifica cómo los procesos de una aplicación, que se ejecutan en diferentes sistemas finales, intercambian mensajes entre sí. Este tipo de protocolo define:

- Los tipos de mensajes que se envían, como mensajes de solicitud y de respuesta.

- La sintaxis de los mensajes, es decir, la estructura de los campos dentro de cada mensaje y cómo se separan o identifican esos campos.

- La semántica de los campos, indicando qué significa la información contenida en cada uno.

- Las reglas de comunicación, que establecen cuándo un proceso debe enviar un mensaje y cómo debe reaccionar al recibir uno.

En resumen, los protocolos de capa de aplicación aseguran que las aplicaciones puedan comunicarse correctamente y coordinarse en la red, haciendo posible servicios como el correo electrónico, la web o la transferencia de archivos.

** Detalle el protocolo de aplicación desarrollado en este trabajo.

** La capa de transporte del stack TCP/IP ofrece dos protocolos: TCP y UDP.

*** ¿Qué servicios proveen dichos protocolos?

Ambos protocolos proveen los siguientes servicios:

- *Multiplexación/Demultiplexación*: son los mecanismos que permiten extender el servicio de entrega de IP entre dos end systems a un servicio de entrega entre dos procesos que se ejecutan en esos sistemas. Dichos mecanismos permiten identificar a qué proceso pertenece cada ssegmento recibido.
- *Chequeo de integridad*: se verifica que no haya errores en los datos mediante un campo de checksum en los headers de ambos protocolos.

UDP no realiza ninguna otra función extra. Por lo tanto, su servicio es:
- *No confiable*: no garantiza que la entrega de los paquetes sea exitosa, ni tampoco que lleguen en orden.
- *Sin conexión*: cada paquete datagrama se envía de manera independiente, sin garantías de que el receptor esté listo o incluso disponible.

Por su parte, TCP ofrece las siguientes funcionalidades adicionales:
- *Orientado a la conexión*: antes de que un proceso de aplicación pueda comenzar a enviar datos a otro, ambos procesos deben comunicarse entre sí; es decir, deben enviarse algunos segmentos preliminares para establecer los parámetros de la transferencia de datos subsiguiente. Se trata de una conexión lógica con un estado en común que reside en TCP de los hosts.
- *Transferencia de datos confiable*: garantiza la entrega, el orden y la no corrupción de los datos. Esto lo logra mediante timers, numeros de secuencia y ACKs (flags que indican que un paquete fue entregado correctamente).
- *Control de congestión*: festiona que no se saturen los enlaces. Es más bien un servicio para la red.
- *Control de flujo*: para eliminar la posibilidad de que el remitente desborde el búfer del receptor. Hace coincidir la velocidad a la que el remitente envía con la velocidad a la que la aplicación receptora lee.

*** ¿Cuáles son sus características?

Algunas de las características de UDP son las siguientes:
- *Pequeño overhead de header por paquete*: UDP posee un header pequeño (8 bytes) en comparación con TCP (20 bytes)
- *Sin estado de conexión*: UDP no mantiene un estado de conexión en los end systems, por lo que no rastrea ningún parámetro. Por esta razón, un servidor dedicado a una aplicación específica generalmente puede admitir muchos más clientes activos cuando la aplicación se ejecuta mediante UDP en lugar de TCP.
- *Sin retraso por conexión*: UDP no induce ningún retraso para establecer una conexión, a diferencia de TCP que posee un handshake de tres pasos.

Por su parte, TCP posee las siguientes características:

- *Full-duplex*: dada una conexión TCP entre dos hosts, digamos A y B, la información puede fluir de A a B al mismo tiempo que fluye información de B a A.
- *Conexión point-to-point*: la conexión de TCP únicamente se puede establecer entre un único remitente y un único receptor, no admite multicasting.
- *Three-Way Handshake*: para establecer la conexión mencionada anteriormente se realiza un procedimiento donde se envían tres segmentos.

*** ¿Cuando es apropiado utilizar cada uno?

Ninguno de estos protocolos es mejor que el otro. Para decidir cuál de ellos utilizar, se deben tener en cuenta las necesidades de la aplicación.
Debido a las características mencionadas anteriormente, UDP resulta más apropiado para aplicaciones que requieran mayor velocidad sin que sea tan sensible a algunas pérdidas de paquetes, por ejemplo plataformas de streaming, y si se tiene un servidor dedicado a una aplicación específica que necesita poder admitir muchos más clientes activos.
Por otro lado, TCP es más ventajoso para las aplicaciones que necesitan un transporte confiable de los datos. Algunos ejemplos son el email y la web.

* Dificultades Encontradas
* Conclusion
* Anexo: Fragmentacion IPv4
** Enunciado :noexport:
El siguiente ejercicio se plantea como objetivo la comprensión y la puesta en
práctica de los conceptos y herramientas necesarias para la comprobación del
proceso de fragmentación en IPv4. Para lograr este objetivo, se deberá crear
una red virtual que contenga la topología propuesta y se deberá generar tráfico
para poder analizar el comportamiento del protocolo IPv4:

 - Utilizando mininet. se pide armar una topología lineal formada por dos hosts conectados a traves de 3 switches.
 - Reducir el MTU de alguna interfaz del switch central. Configurar un packet loss en una interfaz del switch conectada
 - al segundo host.
 - Generar tráfico UDP/TCP utilizando iperf. Configurar el tamaño de los paquetes de manera tal que se produzca el
 - proceso de fragmentación.
 - Capturar el tráfico utilizando wireshark.
 - Analizar el tráfico generado en la topología y comprobar empíricamente los siguientes fenómenos:
 - Proceso de fragmentación
 - Funcionamiento de TCP ante la pérdida de un fragmento
 - Funcionamiento de UDP ante la pérdida de un fragmento
 - Aumento de tráfico al reducirse el MTU mínimo de la red.
** Analisis
