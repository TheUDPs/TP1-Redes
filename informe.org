#+LANGUAGE: es
#+OPTIONS: toc:nil title:nil

#+LATEX_CLASS_OPTIONS: [titlepage,a4paper]
#+LATEX_HEADER_EXTRA: \hypersetup{colorlinks=true,linkcolor=black,urlcolor=blue,bookmarksopen=true}
#+LATEX_HEADER_EXTRA: \usepackage{a4wide}
#+LATEX_HEADER_EXTRA: \usepackage{bookmark}
#+LATEX_HEADER_EXTRA: \usepackage{fancyhdr}
#+LATEX_HEADER_EXTRA: \usepackage[spanish]{babel}
#+LATEX_HEADER_EXTRA: \usepackage[utf8]{inputenc}
#+LATEX_HEADER_EXTRA: \usepackage[T1]{fontenc}
#+LATEX_HEADER_EXTRA: \usepackage{graphicx}
#+LATEX_HEADER_EXTRA: \usepackage{float}
#+LATEX_HEADER_EXTRA: \usepackage{minted}
#+LATEX_HEADER_EXTRA: \usepackage{svg}
#+LATEX_HEADER_EXTRA: \usepackage{xcolor}
#+LATEX_HEADER_EXTRA: \pagestyle{fancy}
#+LATEX_HEADER_EXTRA: \fancyhf{}
#+LATEX_HEADER_EXTRA: \fancyhead[L]{TP1 - Grupo 2}
#+LATEX_HEADER_EXTRA: \fancyhead[R]{Redes - FIUBA}
#+LATEX_HEADER_EXTRA: \renewcommand{\headrulewidth}{0.4pt}
#+LATEX_HEADER_EXTRA: \fancyfoot[C]{\thepage}
#+LATEX_HEADER_EXTRA: \renewcommand{\footrulewidth}{0.4pt}
#+LATEX_HEADER_EXTRA: \usemintedstyle{stata-light}
#+LATEX_HEADER_EXTRA: \newminted{c}{bgcolor={rgb}{0.95,0.95,0.95}}
#+LATEX_HEADER_EXTRA: \usepackage{color}
#+LATEX_HEADER_EXTRA: \usepackage[utf8]{inputenc}
#+LATEX_HEADER_EXTRA: \usepackage{fancyvrb}
#+LATEX_HEADER_EXTRA: \fvset{framesep=1mm,fontfamily=courier,fontsize=\scriptsize,numbers=left,framerule=.3mm,numbersep=1mm}
#+LATEX_HEADER_EXTRA: \usepackage[nottoc]{tocbibind}
#+LATEX_HEADER_EXTRA: \usepackage{amsmath}
#+LATEX_HEADER_EXTRA: \usepackage{changepage}

#+NAME: setup
#+BEGIN_SRC emacs-lisp :results silent :exports none
  (setq org-latex-minted-options
    '(("bgcolor" "bg")))
#+END_SRC

#+BEGIN_EXPORT latex
\begin{titlepage}
    \hfill\includegraphics[width=6cm]{docs/imgs/logofiuba.jpg}
    \centering
    \vfill
    \Huge \textbf{Trabajo Práctico 1}
    \vskip2cm
    \Large [TA048] Redes \\
    Primer cuatrimestre de 2025\\
    \vfill
    \begin{tabular}{ | l | l | l | }
      \hline
      Alumno & Padron & Email \\ \hline
      AVALOS, Victoria & 108434 & vavalos@fi.uba.ar \\ \hline
      CASTRO MARTINEZ, Jose Ignacio & 106957 & jcastrom@fi.uba.ar \\ \hline
      CIPRIANO, Victor & 106593 & vcipriano@fi.uba.ar \\ \hline
      DEALBERA, Pablo Andres & 106858 & pdealbera@fi.uba.ar \\ \hline
      DIEM, Walter Gabriel & 105618 & wdiem@fi.uba.ar \\ \hline
    \end{tabular}
    \vfill
\end{titlepage}
\tableofcontents
\newpage
\definecolor{bg}{rgb}{0.95,0.95,0.95}
#+END_EXPORT

* Introducción

En el presente trabajo práctico se desarrolla una aplicación de red para la transferencia de archivos, basada en una arquitectura 
cliente-servidor, con el objetivo principal de implementar mecanismos de transferencia de datos confiable. Para ello, se trabajará 
sobre la capa de transporte, utilizando específicamente el protocolo UDP, lo cual requiere diseñar e implementar soluciones 
personalizadas que garanticen la entrega de datos confiable. En este marco, se explorarán los principios del concepto de  
Reliable Data Transfer (RDT), implementando dos de sus variantes: Stop-and-Wait y Go-Back-N (GBN). La comunicación entre procesos 
se llevará a cabo mediante la interfaz de sockets de Python, y se utilizará la herramienta Mininet para simular diferentes 
condiciones de red y evaluar el comportamiento de las implementaciones, incluyendo escenarios con pérdida de paquetes.


* Hipótesis y suposiciones realizadas

- La carga/descarga no va a conservar la metadata del archivo. Es decir, si yo descargo un archivo, ese archivo va a tener metadata como si yo hubiera creado el archivo desde cero usando `touch archivo`.
- Si el cliente utiliza otro protocolo para comunicarse con el server, el server debe rechazar este pedido. (PROTOCOL MISSMATCH). El header tendra un campo dedicado a esto.
- El argumento de FILENAME sera opcional, en caso de no estar, se utiliza el nombre original del archivo.
- Por simplicidad, vamos a guardar todos los archivos en DIRPATH sin ningún nivel de subdirectorios.
- Por simplicidad, vamos a tener un tamaño máximo de 2GB para la subida y descarga de archivos.
- Los archivos en proceso de escritura se van a escribir en una ubicación temporal para evitar que se corrompan en la ubicación que el cliente pidió.
- Usar seek y bufferear para leer el archivo. Leer con slices del buffer.

* Implementación
** Topología

#+ATTR_LATEX: :width 0.5\textwidth
[[file:docs/imgs/linear_ends_multiple_clients_with_loss.png]]

La topología es una red lineal con 1 host servidor conectado a 3 switches en serie cuyo ultimo switch esta conectado a n hosts clientes. El primer enlace (el conectado entre el servidor y el primero switch) tiene configurado un packet loss del 10\% configurado de forma simetrica 5% de cada lado del enlace.

** Especificación del protocolo Stop-and-Wait

*** General

**** Tamaño máximo de payload

El tamaño máximo de payload es el tamaño máximo de un datagrama UDP menos el tamaño de los headers de IP, UDP y SAW.

Como el MTU que usamos en mininet es 1500, el tamaño máximo de payload es:

\begin{align*}
  \text{HISTORICAL\_MTU} &= 1500 \\
  \text{MAX\_IP\_HEADER\_SIZE} &= 60 \\
  \text{UDP\_HEADER\_SIZE} &= 8 \\
  \text{SAW\_PROTOCOL\_HEADER\_SIZE} &= 6 \\
\end{align*}

\begin{align*}
\text{FILE\_CHUNK\_SIZE} = \text{HISTORICAL\_MTU} - \text{MAX\_IP\_HEADER\_SIZE} \\
                        -\ \text{UDP\_HEADER\_SIZE} - \text{SAW\_PROTOCOL\_HEADER\_SIZE}
\end{align*}

*** Handshake

#+BEGIN_SRC plantuml :file docs/imgs/connection-handshake.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

Client ->(10) Server : SYN, seq 0
Server ->(10) Client : SYN, ACK, seq 1
Client ->(10) Server : ACK, OP_CODE (piggybacked)
Server ->(10) Client : ACK
@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.5\textwidth
#+RESULTS:
[[file:docs/imgs/connection-handshake.png]]

La idea es usar este handshake para inicialización de recursos del servidor y check de protocolo. \\

Se usa la nomenclatura S para mencionar al servidor y C para el cliente.

_Mensajes para caso Download y caso Upload_:

1. C \rightarrow S: con flag SYN para declarar una solicitud de conexión y el protocolo

*Flujo normal (mismo protocolo)*:

2. [@2] S \rightarrow C: con flag de SYN y ACK para declarar que se acepta la conexión y el puerto donde se va a escuchar el resto.
3. C \rightarrow S: con flag ACK al mismo welcoming socket.

*Flujo de error (distinto protocolo)*:

2. [@2] S \rightarrow C: con flag FIN para denegar la conexión por usar un protocolo distinto.

Se hace una transferencia de puerto para que el welcoming socket se encargue solamente de establecer conexiones y el nuevo puerto maneje la transferencia de datos del archivo. El último ACK de parte del cliente asegura que se recibió el puerto donde se tiene que comunicar y es seguro hacer el cambio de socket.

*** Etapa de configuración y Transferencia

El cliente ya sabe que tiene que comunicarse con el nuevo puerto.

Se envía primero la configuración para saber si la operación es valida y tener en cuenta casos de error, y luego se hace la transferencia. \\

_Mensajes para caso Download y caso Upload_:

1. C \rightarrow S: se declara la operación (OP), que puede ser download (0) o upload (1)
2. S \rightarrow C: ACK de la operación (no falla)

_Continuación de mensajes para caso Download_:

3. [@3] Mensaje 3 C \rightarrow S: filename

*Flujo Normal*:

4. [@4] S \rightarrow C: ACK + comienzo de datos (piggybacked)
5. C \rightarrow S: ACK
6. S \rightarrow C: continuacion de datos

*Flujo de error (no existe un archivo con ese nombre)*:

4. [@4] S \rightarrow C: FIN, se termina la conexión

_Continuación de mensajes para caso Upload_:

3. [@3] C \rightarrow S: filename

*Flujo de error (ya existe un archivo con ese nombre)*:

4. [@4] S \rightarrow C: FIN, se termina la conexión

*Flujo normal*:

4. [@4] S \rightarrow C: ACK
5. C \rightarrow S: filesize

*Flujo de error (archivo es más grande que el tamaño máximo o [TODO] no hay más espacio en disco)*:

6. [@6] S \rightarrow C: FIN, se termina la conexión

*Flujo normal*:

6. [@6] S \rightarrow C: ACK
7. C \rightarrow S: comienzo de datos
8. S \rightarrow C: ACK
9. C \rightarrow S: continuacion de datos

*** Cierre

El flag FIN va piggybacked con la última data para que sea más eficiente. El receptor confirma con un ACK + FIN para que el emisor sepa que le llego la informacion, y por si este se pierde está el último ACK para confirmar el cierre de parte del emisor. \\

**** Mensajes para caso Download

#+BEGIN_SRC plantuml :file docs/imgs/download.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

Client ->(10) Server : Filename
Server ->(10) Client : ACK, Data Chunk 1 (piggybacked)
Client ->(10) Server : ACK of Data Chunk 1
Server ->(10) Client : Data Chunk 2
Client ->(10) Server : ACK of Data Chunk 2
Server ->(10) Client : ...
Client ->(10) Server : ...
Server ->(10) Client : FIN, Data Chunk n
Client ->(10) Server : FIN, ACK of Data Chunk n
@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.5\textwidth
#+RESULTS:
[[file:docs/imgs/download.png]]

1. S \rightarrow C: ultima data, va piggybacked el flag FIN
2. C \rightarrow S: ACK + FIN
3. S \rightarrow C: ACK

**** Mensajes para caso Upload:

#+BEGIN_SRC plantuml :file docs/imgs/upload.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

Client ->(10) Server : Filename
Server ->(10) Client : ACK
Client ->(10) Server : Filesize
Server ->(10) Client : ACK
Client ->(10) Server : Data
@enduml
#+END_SRC

#+ATTR_LATEX: :width 0.5\textwidth
#+RESULTS:
[[file:docs/imgs/upload.png]]

1. C \rightarrow S: ultima data, va piggybacked el flag FIN
2. S \rightarrow C: ACK + FIN
3. C \rightarrow S: ACK

** Especificación del protocolo Go-Back-N
*** Ciclo de Vida

#+BEGIN_SRC plantuml :file docs/imgs/gbn.png :exports results
@startuml
skinparam sequenceMessageAlign center
skinparam ParticipantPadding 100
scale 2.0
participant Client
participant Server

group ‎  [Handshake]

Client ->(10) Server : [SYN]\nseq=0, ack=0
Server ->(10) Client : [SYN], [ACK]\nseq=0, ack=0

Client ->(10) Server : [ACK]\nseq=1, ack=1\n data=1 (op_code)
Server ->(10) Client : [ACK]\nseq=1, ack=1

else Configuration

Client ->(10) Server : seq=2, ack=2\n data=report.pdf
Server ->(10) Client : [ACK]\nseq=2, ack=2\npayload_length=1416\n data=101110...
Client ->(10) Server : [ACK]\nseq=2, ack=2

else File transfer

Server ->(10) Client : seq=3, ack=2\npayload_length=1416\n data=101110...
Server ->(10) Client : [FIN]\nseq=4, ack=2\npayload_length=168\n data=101110...

Client ->(10) Server : [ACK]\nseq=3, ack=3
Client ->(10) Server : [ACK]\nseq=4, ack=4

else Closing handshake

Client ->(10) Server : [FIN]\nseq=4, ack=4
Server ->(10) Client : [ACK]\nseq=5, ack=5

end

caption \nGo-Back-N protocol with window of\n 2 packets. Client downloads file \n(report.pdf of size 3000 bytes) from server
#+END_SRC

#+ATTR_LATEX: :width 0.7\textwidth
#+RESULTS:
[[file:docs/imgs/gbn.png]]


*** Análisis del ciclo de vida de una transferencia con Go-Back-N

El siguiente análisis describe el comportamiento de una transferencia de
archivos mediante el protocolo Go-Back-N (GBN) con una ventana de tamaño 2. En
este caso, el cliente descarga un archivo (`report.pdf`) de 3000 bytes desde el
servidor. El ciclo de vida de la request se puede dividir en cuatro fases
principales:

**** Establecimiento de la conexión (Handshake):
- El cliente inicia la conexión enviando un paquete con las banderas `SYN`, con `seq=0` y `ack=0`.
- El servidor responde con un paquete combinado `SYN, ACK` manteniendo los mismos valores de secuencia y acuse.
- El cliente confirma la recepción enviando un paquete `ACK` con `seq=1` y `ack=1`, incluyendo una operación de configuración (data=1 op_code).
- El servidor responde con un `ACK` para confirmar la recepción del mensaje de configuración.

**** Configuración:
- El cliente envía un paquete con `seq=2`, `ack=2` y `data=report.pdf`, indicando el nombre del archivo solicitado.
- El servidor responde con un paquete de datos con `seq=2`, `ack=2`, una longitud de carga útil de 1416 bytes y los primeros bits del archivo.
- El cliente confirma la recepción con un `ACK` correspondiente.

**** Transferencia del archivo:
- El servidor envía el segundo fragmento de datos (`seq=3`, `ack=2`), también de 1416 bytes.
- Posteriormente, se envía un paquete con la bandera `FIN` (`seq=4`, `ack=2`, `payload_length=168`), marcando el fin de la transferencia.
- El cliente responde con dos `ACK`, uno para cada paquete recibido correctamente: `seq=3, ack=3` y `seq=4, ack=4`.

**** Cierre de la conexión (Closing handshake):
- El cliente envía un `FIN` para finalizar su lado de la comunicación (`seq=4, ack=4`).
- El servidor responde con un `ACK` final (`seq=5, ack=5`), completando el cierre de la conexión de manera ordenada.

* Pruebas

** Tabla de Datos de Wireshark

\begin{adjustwidth}{-3cm}{-3cm}
\begin{center}
\begin{tabular}{rrrrlrlrlllrrl}
No & Time & Src & Dst & Proto & Len & Type & SEQ & ACK & SYN & FIN & SrcPort & DstPort\\[0pt]
\hline
1 & 0.000000000 & 10.0.1.1 & 10.0.0.1 & SAW & 48 & Stop-and-Wait & 0 & False & True & False & 52515 & 0\\[0pt]
2 & 0.000191297 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 0 & True & True & False & 41367 & 0\\[0pt]
3 & 0.002208402 & 10.0.1.1 & 10.0.0.1 & SAW & 50 & Stop-and-Wait & 1 & True & False & False & 52515 & 2\\[0pt]
4 & 0.002801150 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 1 & True & False & False & 41367 & 0\\[0pt]
5 & 0.004355272 & 10.0.1.1 & 10.0.0.1 & SAW & 53 & Stop-and-Wait & 0 & False & False & False & 52515 & 5\\[0pt]
6 & 0.004722710 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 0 & True & False & False & 41367 & 0\\[0pt]
7 & 0.005754904 & 10.0.1.1 & 10.0.0.1 & SAW & 52 & Stop-and-Wait & 1 & False & False & False & 52515 & 4\\[0pt]
8 & 0.005879502 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 1 & True & False & False & 41367 & 0\\[0pt]
9 & 0.006562696 & 10.0.1.1 & 10.0.0.1 & SAW & 1474 & Stop-and-Wait & 0 & False & False & False & 52515 & 1426\\[0pt]
10 & 0.006634214 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 0 & True & False & False & 41367 & 0\\[0pt]
11 & 0.006819155 & 10.0.1.1 & 10.0.0.1 & SAW & 1474 & Stop-and-Wait & 1 & False & False & False & 52515 & 1426\\[0pt]
12 & 0.006887880 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 1 & True & False & False & 41367 & 0\\[0pt]
\ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{} & \ldots{}\ldots{}\\[0pt]
384 & 0.036747322 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 1 & True & False & False & 41367 & 0\\[0pt]
385 & 0.036806828 & 10.0.1.1 & 10.0.0.1 & SAW & 1474 & Stop-and-Wait & 0 & False & False & False & 52515 & 1426\\[0pt]
386 & 0.036860606 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 0 & True & False & False & 41367 & 0\\[0pt]
387 & 0.037000220 & 10.0.1.1 & 10.0.0.1 & SAW & 1474 & Stop-and-Wait & 1 & False & False & False & 52515 & 1426\\[0pt]
388 & 0.037084310 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 1 & True & False & False & 41367 & 0\\[0pt]
389 & 0.037217987 & 10.0.1.1 & 10.0.0.1 & SAW & 363 & Stop-and-Wait & 0 & False & False & True & 52515 & 315\\[0pt]
390 & 0.037459011 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 0 & True & False & False & 41367 & 0\\[0pt]
391 & 0.037511183 & 10.0.0.1 & 10.0.1.1 & SAW & 48 & Stop-and-Wait & 0 & False & False & True & 41367 & 0\\[0pt]
392 & 0.037580397 & 10.0.1.1 & 10.0.0.1 & SAW & 48 & Stop-and-Wait & 1 & True & False & False & 52515 & 0\\[0pt]
\end{tabular}
\end{center}
\end{adjustwidth}

** Análisis de la comunicación Stop-and-Wait

La tabla presentada muestra una traza de paquetes intercambiados entre dos nodos de mininet (10.0.1.1 y 10.0.0.1) utilizando el protocolo desarrollado con el esquema Stop-and-Wait. Este protocolo garantiza la entrega ordenada y libre de errores mediante el envío secuencial de paquetes, esperando una confirmación (ACK) por cada uno antes de continuar con el siguiente.

El ciclo de vida de la comunicación puede dividirse en tres fases:

**1. Establecimiento de la conexión:**
- El cliente (10.0.1.1) inicia la conexión enviando un paquete con la bandera `SYN` activada.
- El servidor (10.0.0.1) responde con un paquete que contiene tanto `SYN` como `ACK`, indicando aceptación.
- Finalmente, el cliente responde con un `ACK`, completando el procedimiento de handshake.

**2. Transferencia de datos:**
- Una vez establecida la conexión, el cliente comienza a enviar datos, alternando los números de secuencia (SEQ) entre 0 y 1. Este comportamiento es característico del protocolo Stop-and-Wait.
- Por cada paquete de datos enviado, el servidor responde con un paquete de confirmación (`ACK`) para indicar que ha recibido correctamente el contenido.
- El campo `Len` refleja el tamaño de los datos transportados, y los puertos de origen y destino se utilizan para mantener la sesión activa entre los procesos involucrados.

**3. Finalización de la conexión:**
- El cliente inicia el cierre de la sesión enviando un paquete con la bandera `FIN` activada.
- El servidor responde primero con un `ACK`, y luego con su propio paquete `FIN`, indicando que también desea cerrar la conexión.
- Finalmente, el cliente responde con un `ACK`, completando el cierre de la comunicación de manera ordenada.

En resumen, esta captura de paquetes evidencia el funcionamiento correcto de una implementación del protocolo Stop-and-Wait, en donde cada paquete enviado es seguido por una respuesta de confirmación, y el inicio y cierre de la conexión se realizan mediante el protocolo RDT.

* Preguntas a Responder
** Describa la arquitectura Cliente-Servidor.
La arquitectura Cliente-Servidor es una de dos arquitecturas más comunes. En esta arquitectura hay un /host/ (/end system/) llamado /server/ que esta siempre encendido que pasivamente escucha /requests/ de otros /hosts/ llamados /clients/ que son agentes activos que inician la comunicación con el /server/.

Un ejemplo de esta arquitectura es una aplicacion Web donde hay un /Web server/ que escucha /requests/ de navegadores web. El navegador web es el cliente que inicia la comunicación y el /Web server/ es el servidor que responde a los /requests/. Estos mensajes tienen el formato de Capa de Aplicación HTTP.

*** Caracteristicas
 - Los clientes son agentes activos que inician la comunicación.
 - Los clientes no se comunican entre si.
 - Los clientes no necesitan estar encendidos todo el tiempo ni tener una IP fija.
 - Los servidores son pasivos y siempre están encendidos.
 - Los servidores *deben* tener una IP fija bien conocida (/well-known IP address/) que se puede resolver con un nombre de dominio DNS (/domain name/).
 - Los servidores pueden tener múltiples clientes conectados al mismo tiempo.

*** Ventajas
 - Diseño simple usando protocolos sin estado como HTTP donde el servidor no
   necesita mantener informacion sobre clientes ya que se puede guardar
   informacion del cliente en /cookies/ del cliente y estos se transmitidos en
   /headers/ HTTP.
 - Puede soportar un gran numero de clientes.

*** Desventajas
 - Un solo punto de falla. Si el servidor se cae, el servicio se cae.
 - El servidor debe estar encendido todo el tiempo.
 - Gran costo para escalar, ya que a medida de que el servicio tiene mas
   usuarios, el servidor debe tambien aumentar su capacidad de procesar mas
   clientes.

** ¿Cuál es la función de un protocolo de capa de aplicación?

Un protocolo de capa de aplicación especifica cómo los procesos de una aplicación, que se ejecutan en diferentes sistemas finales, intercambian mensajes entre sí. Este tipo de protocolo define:

- Los tipos de mensajes que se envían, como mensajes de solicitud y de respuesta.

- La sintaxis de los mensajes, es decir, la estructura de los campos dentro de cada mensaje y cómo se separan o identifican esos campos.

- La semántica de los campos, indicando qué significa la información contenida en cada uno.

- Las reglas de comunicación, que establecen cuándo un proceso debe enviar un mensaje y cómo debe reaccionar al recibir uno.

En resumen, los protocolos de capa de aplicación aseguran que las aplicaciones puedan comunicarse correctamente y coordinarse en la red, haciendo posible servicios como el correo electrónico, la web o la transferencia de archivos.

** Detalle el protocolo de aplicación desarrollado en este trabajo.

** La capa de transporte del stack TCP/IP ofrece dos protocolos: TCP y UDP.

*** ¿Qué servicios proveen dichos protocolos?

Ambos protocolos proveen los siguientes servicios:

- *Multiplexación/Demultiplexación*: son los mecanismos que permiten extender el servicio de entrega de IP entre dos end systems a un servicio de entrega entre dos procesos que se ejecutan en esos sistemas. Dichos mecanismos permiten identificar a qué proceso pertenece cada ssegmento recibido.
- *Chequeo de integridad*: se verifica que no haya errores en los datos mediante un campo de checksum en los headers de ambos protocolos.

UDP no realiza ninguna otra función extra. Por lo tanto, su servicio es:
- *No confiable*: no garantiza que la entrega de los paquetes sea exitosa, ni tampoco que lleguen en orden.
- *Sin conexión*: cada paquete datagrama se envía de manera independiente, sin garantías de que el receptor esté listo o incluso disponible.

Por su parte, TCP ofrece las siguientes funcionalidades adicionales:
- *Orientado a la conexión*: antes de que un proceso de aplicación pueda comenzar a enviar datos a otro, ambos procesos deben comunicarse entre sí; es decir, deben enviarse algunos segmentos preliminares para establecer los parámetros de la transferencia de datos subsiguiente. Se trata de una conexión lógica con un estado en común que reside en TCP de los hosts.
- *Transferencia de datos confiable*: garantiza la entrega, el orden y la no corrupción de los datos. Esto lo logra mediante timers, numeros de secuencia y ACKs (flags que indican que un paquete fue entregado correctamente).
- *Control de congestión*: festiona que no se saturen los enlaces. Es más bien un servicio para la red.
- *Control de flujo*: para eliminar la posibilidad de que el remitente desborde el búfer del receptor. Hace coincidir la velocidad a la que el remitente envía con la velocidad a la que la aplicación receptora lee.

*** ¿Cuáles son sus características?

Algunas de las características de UDP son las siguientes:
- *Pequeño overhead de header por paquete*: UDP posee un header pequeño (8 bytes) en comparación con TCP (20 bytes)
- *Sin estado de conexión*: UDP no mantiene un estado de conexión en los end systems, por lo que no rastrea ningún parámetro. Por esta razón, un servidor dedicado a una aplicación específica generalmente puede admitir muchos más clientes activos cuando la aplicación se ejecuta mediante UDP en lugar de TCP.
- *Sin retraso por conexión*: UDP no induce ningún retraso para establecer una conexión, a diferencia de TCP que posee un handshake de tres pasos.

Por su parte, TCP posee las siguientes características:

- *Full-duplex*: dada una conexión TCP entre dos hosts, digamos A y B, la información puede fluir de A a B al mismo tiempo que fluye información de B a A.
- *Conexión point-to-point*: la conexión de TCP únicamente se puede establecer entre un único remitente y un único receptor, no admite multicasting.
- *Three-Way Handshake*: para establecer la conexión mencionada anteriormente se realiza un procedimiento donde se envían tres segmentos.

*** ¿Cuando es apropiado utilizar cada uno?

Ninguno de estos protocolos es mejor que el otro. Para decidir cuál de ellos utilizar, se deben tener en cuenta las necesidades de la aplicación.
Debido a las características mencionadas anteriormente, UDP resulta más apropiado para aplicaciones que requieran mayor velocidad sin que sea tan sensible a algunas pérdidas de paquetes, por ejemplo plataformas de streaming, y si se tiene un servidor dedicado a una aplicación específica que necesita poder admitir muchos más clientes activos.
Por otro lado, TCP es más ventajoso para las aplicaciones que necesitan un transporte confiable de los datos. Algunos ejemplos son el email y la web.

* Dificultades Encontradas
* Conclusion
* Anexo: Fragmentacion IPv4
** Enunciado :noexport:
El siguiente ejercicio se plantea como objetivo la comprensión y la puesta en
práctica de los conceptos y herramientas necesarias para la comprobación del
proceso de fragmentación en IPv4. Para lograr este objetivo, se deberá crear
una red virtual que contenga la topología propuesta y se deberá generar tráfico
para poder analizar el comportamiento del protocolo IPv4:

 - Utilizando mininet. se pide armar una topología lineal formada por dos hosts conectados a traves de 3 switches.
 - Reducir el MTU de alguna interfaz del switch central. Configurar un packet loss en una interfaz del switch conectada
 - al segundo host.
 - Generar tráfico UDP/TCP utilizando iperf. Configurar el tamaño de los paquetes de manera tal que se produzca el
 - proceso de fragmentación.
 - Capturar el tráfico utilizando wireshark.
 - Analizar el tráfico generado en la topología y comprobar empíricamente los siguientes fenómenos:
 - Proceso de fragmentación
 - Funcionamiento de TCP ante la pérdida de un fragmento
 - Funcionamiento de UDP ante la pérdida de un fragmento
 - Aumento de tráfico al reducirse el MTU mínimo de la red.
** Analisis
