#+LANGUAGE: es
#+OPTIONS: toc:nil title:nil

#+LATEX_CLASS_OPTIONS: [titlepage,a4paper]
#+LATEX_HEADER_EXTRA: \hypersetup{colorlinks=true,linkcolor=black,urlcolor=blue,bookmarksopen=true}
#+LATEX_HEADER_EXTRA: \usepackage{a4wide}
#+LATEX_HEADER_EXTRA: \usepackage{bookmark}
#+LATEX_HEADER_EXTRA: \usepackage{fancyhdr}
#+LATEX_HEADER_EXTRA: \usepackage[spanish]{babel}
#+LATEX_HEADER_EXTRA: \usepackage[utf8]{inputenc}
#+LATEX_HEADER_EXTRA: \usepackage[T1]{fontenc}
#+LATEX_HEADER_EXTRA: \usepackage{graphicx}
#+LATEX_HEADER_EXTRA: \usepackage{float}
#+LATEX_HEADER_EXTRA: \usepackage{minted}
#+LATEX_HEADER_EXTRA: \usepackage{svg}
#+LATEX_HEADER_EXTRA: \usepackage{xcolor}
#+LATEX_HEADER_EXTRA: \pagestyle{fancy}
#+LATEX_HEADER_EXTRA: \fancyhf{}
#+LATEX_HEADER_EXTRA: \fancyhead[L]{TP1 - Grupo 2}
#+LATEX_HEADER_EXTRA: \fancyhead[R]{Redes - FIUBA}
#+LATEX_HEADER_EXTRA: \renewcommand{\headrulewidth}{0.4pt}
#+LATEX_HEADER_EXTRA: \fancyfoot[C]{\thepage}
#+LATEX_HEADER_EXTRA: \renewcommand{\footrulewidth}{0.4pt}
#+LATEX_HEADER_EXTRA: \usemintedstyle{stata-light}
#+LATEX_HEADER_EXTRA: \newminted{c}{bgcolor={rgb}{0.95,0.95,0.95}}
#+LATEX_HEADER_EXTRA: \usepackage{color}
#+LATEX_HEADER_EXTRA: \usepackage[utf8]{inputenc}
#+LATEX_HEADER_EXTRA: \usepackage{fancyvrb}
#+LATEX_HEADER_EXTRA: \fvset{framesep=1mm,fontfamily=courier,fontsize=\scriptsize,numbers=left,framerule=.3mm,numbersep=1mm}
#+LATEX_HEADER_EXTRA: \usepackage[nottoc]{tocbibind}

#+NAME: setup
#+BEGIN_SRC emacs-lisp :results silent :exports none
  (setq org-latex-minted-options
    '(("bgcolor" "bg")))
#+END_SRC

#+BEGIN_EXPORT latex
\begin{titlepage}
    \hfill\includegraphics[width=6cm]{docs/imgs/logofiuba.jpg}
    \centering
    \vfill
    \Huge \textbf{Trabajo Práctico 1}
    \vskip2cm
    \Large [TA048] Redes \\
    Primer cuatrimestre de 2025\\
    \vfill
    \begin{tabular}{ | l | l | l | }
      \hline
      Alumno & Padron & Email \\ \hline
      AVALOS, Victoria & 108434 & vavalos@fi.uba.ar \\ \hline
      CASTRO MARTINEZ, Jose Ignacio & 106957 & jcastrom@fi.uba.ar \\ \hline
      CIPRIANO, Victor & 106593 & vcipriano@fi.uba.ar \\ \hline
      DEALBERA, Pablo Andres & 106858 & pdealbera@fi.uba.ar \\ \hline
      DIEM, Walter Gabriel & 105618 & wdiem@fi.uba.ar \\ \hline
    \end{tabular}
    \vfill
\end{titlepage}
\tableofcontents
\newpage
\definecolor{bg}{rgb}{0.95,0.95,0.95}
#+END_EXPORT

* Introduccion

\color{red}
- La carga/descarga no va a conservar la metadata del archivo. Es decir, si yo descargo un archivo, ese archivo va a tener metadata como si yo hubiera creado el archivo desde cero usando `touch archivo`.
- Si el cliente utiliza otro protocolo para comunicarse con el server, el server debe rechazar este pedido. (PROTOCOL_MISSMATCH). El header tendra un campo dedicado a esto.
- El argumento de FILENAME sera opcional, en caso de no estar, se utiliza el nombre original del archivo.
- Por simplicidad, vamos a guardar todos los archivos en DIRPATH sin ningun nivel de subdirectorios.
- Por simplicidad, vamos a tener un tamaño maximo de 2GB para la subida y descarga de archivos.
- Los archivos en proceso de escritura se van a escribir en una ubicacion temporal para evitar que se corrompan en la ubicacion que el cliente pidio.
- Usar seek y bufferear para leer el archivo. Leer con slices del buffer.
Caso borde:
Dos clientes cargando y descargando el mismo archivo al mismo tiempo.
\color{black}

* Implementacion
** Topología

#+BEGIN_SRC dot :file docs/imgs/topology.png :exports results
graph mininet {
    rankdir=TB;

    { rank=source; h1 }
    { rank=same; s1 }
    { rank=same; s2 }
    { rank=same; s3 }
    { rank=sink; h2; h3; h4 }

    h1 [shape=box];
    h2 [shape=box];
    h3 [shape=box];
    h4 [shape=box];
    s1 [shape=circle];
    s2 [shape=circle];
    s3 [shape=circle];

    h1 -- s1;
    s1 -- s2;
    s2 -- s3;
    h2 -- s3;
    h3 -- s3;
    h4 -- s3;
}
#+END_SRC

#+RESULTS:
#+ATTR_LATEX: :width 0.5\textwidth
[[file:docs/imgs/topology.png]]

#+ATTR_LATEX: :width 0.5\textwidth
[[file:docs/imgs/linear_ends_1_client.png]]

#+ATTR_LATEX: :width 0.5\textwidth
[[file:docs/imgs/linear_ends_multiple_clients.png]]

#+ATTR_LATEX: :width 0.5\textwidth
[[file:docs/imgs/linear_ends_multiple_clients_with_loss.png]]

** Especificación del protocolo Stop-and-Wait

*** General

Tamaño máximo de payload de: 61440 Bytes (60kB).
Este número se obtiene teniendo en cuenta que el header de UDP posee un tamaño máximo de payload de 65535 (64kB), dejando espacio para los headers.

Se usa la nomenclatura S para mencionar al servidor y C para el cliente.

*** Handshake

La idea es usar este handshake para inicialización de recursos del servidor y check de protocolo. \\

_Mensajes para caso Download y caso Upload_:

1. C \rightarrow S: con flag SYN para declarar una solicitud de conexion y el protocolo

*Flujo normal (mismo protocolo)*:

2. [@2] S \rightarrow C: con flag de SYN y ACK para declarar que se acepta la conexión y el puerto donde se va a escuchar el resto.
3. C \rightarrow S: con flag ACK al mismo welcoming socket.

*Flujo de error (distinto protocolo)*:

2. [@2] S \rightarrow C: con flag FIN para denegar la conexión por usar un protocolo distinto.

Se hace una transferencia de puerto para que el welcoming socket se encargue solamente de establecer conexiones y el nuevo puerto maneje la transferencia de datos del archivo. El último ACK de parte del cliente asegura que se recibió el puerto donde se tiene que comunicar y es seguro hacer el cambio de socket.

*** Etapa de configuración y Transferencia

El cliente ya sabe que tiene que comunicarse con el nuevo puerto.

Se envia primero la configuracion para saber si la operacion es valida y tener en cuenta casos de error, y luego se hace la transferencia. \\

_Mensajes para caso Download y caso Upload_:

1. C \rightarrow S: se declara la operacion (OP), que puede ser download (0) o upload (1)
2. S \rightarrow C: ACK de la operacion (no falla)

_Continuación de mensajes para caso Download_:

3. [@3] Mensaje 3 C \rightarrow S: filename

*Flujo Normal*:

4. [@4] S \rightarrow C: ACK + comienzo de datos (piggybacked)
5. C \rightarrow S: ACK
6. S \rightarrow C: continuacion de datos

*Flujo de error (no existe un archivo con ese nombre)*:

4. [@4] S \rightarrow C: FIN, se termina la conexión

_Continuación de mensajes para caso Upload_:

3. [@3] C \rightarrow S: filename

*Flujo de error (ya existe un archivo con ese nombre)*:

4. [@4] S \rightarrow C: FIN, se termina la conexión

*Flujo normal*:

4. [@4] S \rightarrow C: ACK
5. C \rightarrow S: filesize

*Flujo de error (archivo es más grande que el tamaño máximo o [TODO] no hay más espacio en disco)*:

6. [@6] S \rightarrow C: FIN, se termina la conexión

*Flujo normal*:

6. [@6] S \rightarrow C: ACK
7. C \rightarrow S: comienzo de datos
8. S \rightarrow C: ACK
9. C \rightarrow S: continuacion de datos

*** Cierre

El flag FIN va piggybacked con la última data para que sea más eficiente. El receptor confirma con un ACK + FIN para que el emisor sepa que le llego la informacion, y por si este se pierde está el último ACK para confirmar el cierre de parte del emisor. \\

_Mensajes para caso Download_:

1. S \rightarrow C: ultima data, va piggybacked el flag FIN
2. C \rightarrow S: ACK + FIN
3. S \rightarrow C: ACK

_Mensajes para caso Upload_:

1. C \rightarrow S: ultima data, va piggybacked el flag FIN
2. S \rightarrow C: ACK + FIN
3. C \rightarrow S: ACK

* Pruebas
* Preguntas a Responder
** Describa la arquitectura Cliente-Servidor.
** ¿Cuál es la función de un protocolo de capa de aplicación?

Un protocolo de capa de aplicación especifica cómo los procesos de una aplicación, que se ejecutan en diferentes sistemas finales, intercambian mensajes entre sí. Este tipo de protocolo define:

- Los tipos de mensajes que se envían, como mensajes de solicitud y de respuesta.

- La sintaxis de los mensajes, es decir, la estructura de los campos dentro de cada mensaje y cómo se separan o identifican esos campos.

- La semántica de los campos, indicando qué significa la información contenida en cada uno.

- Las reglas de comunicación, que establecen cuándo un proceso debe enviar un mensaje y cómo debe reaccionar al recibir uno.

En resumen, los protocolos de capa de aplicación aseguran que las aplicaciones puedan comunicarse correctamente y coordinarse en la red, haciendo posible servicios como el correo electrónico, la web o la transferencia de archivos.

* Detalle el protocolo de aplicación desarrollado en este trabajo.

** La capa de transporte del stack TCP/IP ofrece dos protocolos: TCP y UDP.

*** ¿Qué servicios proveen dichos protocolos?

Ambos protocolos proveen los siguientes servicios:

- *Multiplexación/Demultiplexación*: son los mecanismos que permiten extender el servicio de entrega de IP entre dos end systems a un servicio de entrega entre dos procesos que se ejecutan en esos sistemas. Dichos mecanismos permiten identificar a qué proceso pertenece cada ssegmento recibido.
- *Chequeo de integridad*: se verifica que no haya errores en los datos mediante un campo de checksum en los headers de ambos protocolos.

UDP no realiza ninguna otra función extra. Por lo tanto, su servicio es:
- *No confiable*: no garantiza que la entrega de los paquetes sea exitosa, ni tampoco que lleguen en orden.
- *Sin conexión*: 

Por su parte, TCP ofrece las siguientes funcionalidades adicionales: 
- *Orientado a la conexión*: antes de que un proceso de aplicación pueda comenzar a enviar datos a otro, ambos procesos deben comunicarse entre sí; es decir, deben enviarse algunos segmentos preliminares para establecer los parámetros de la transferencia de datos subsiguiente. Se trata de una conexión lógica con un estado en común que reside en TCP de los hosts.
- *Transferencia de datos confiable*: garantiza la entrega, el orden y la no corrupción de los datos. Esto lo logra mediante timers, numeros de secuencia y ACKs (flags que indican que un paquete fue entregado correctamente).
- *Control de congestión*: festiona que no se saturen los enlaces. Es más bien un servicio para la red.
- *Control de flujo*: para eliminar la posibilidad de que el remitente desborde el búfer del receptor. Hace coincidir la velocidad a la que el remitente envía con la velocidad a la que la aplicación receptora lee.

*** ¿Cuáles son sus características?

Algunas de las características de UPD son las siguientes:
- *Pequeño overhead de header por paquete*: UDP posee un header pequeño (8 bytes) en comparación con TCP (20 bytes)
- *Sin estado de conexión*: UDP no mantiene un estado de conexión en los end systems, por lo que no rastrea ningún parámetro. Por esta razón, un servidor dedicado a una aplicación específica generalmente puede admitir muchos más clientes activos cuando la aplicación se ejecuta mediante UDP en lugar de TCP.
- *Sin retraso por conexión*: UDP no induce ningún retraso para establecer una conexión, a diferencia de TCP que posee un handshake de tres pasos.

Por su parte, TPC posee las siguientes características:

- *Full-duplex*: dada una conexión TCP entre dos hosts, digamos A y B, la información puede fluir de A a B al mismo tiempo que fluye información de B a A.
- *Conexión point-to-point*: la conexión de TCP únicamente se puede establecer entre un único remitente y un único receptor, no admite multicasting.
- *Three-Way Handshake*: para establecer la conexión mencionada anteriormente se realiza un procedimiento donde se envían tres segmentos.

*** ¿Cuando es apropiado utilizar cada uno?

Ninguno de estos protocolos es mejor que el otro. Para decidir cuál de ellos utilizar, se deben tener en cuenta las necesidades de la aplicación.
Debido a las características mencionadas anteriormente, UDP resulta más apropiado para aplicaciones que requieran mayor velocidad sin que sea tan sensible a algunas pérdidas de paquetes, por ejemplo plataformas de streaming, y si se tiene un servidor dedicado a una aplicación específica que necesita poder admitir muchos más clientes activos.
Por otro lado, TCP es más ventajoso para las aplicaciones que necesitan un transporte confiable de los datos. Algunos ejemplos son el email y la web.

* Dificultades Encontradas
* Conclusion
* Anexo: Fragmentacion IPv4
** Enunciado :noexport:
El siguiente ejercicio se plantea como objetivo la comprensión y la puesta en
práctica de los conceptos y herramientas necesarias para la comprobación del
proceso de fragmentación en IPv4. Para lograr este objetivo, se deberá crear
una red virtual que contenga la topología propuesta y se deberá generar tráfico
para poder analizar el comportamiento del protocolo IPv4:

 - Utilizando mininet. se pide armar una topología lineal formada por dos hosts conectados a traves de 3 switches.
 - Reducir el MTU de alguna interfaz del switch central. Configurar un packet loss en una interfaz del switch conectada
 - al segundo host.
 - Generar tráfico UDP/TCP utilizando iperf. Configurar el tamaño de los paquetes de manera tal que se produzca el
 - proceso de fragmentación.
 - Capturar el tráfico utilizando wireshark.
 - Analizar el tráfico generado en la topología y comprobar empíricamente los siguientes fenómenos:
 - Proceso de fragmentación
 - Funcionamiento de TCP ante la pérdida de un fragmento
 - Funcionamiento de UDP ante la pérdida de un fragmento
 - Aumento de tráfico al reducirse el MTU mínimo de la red.
** Analisis
