% Created 2025-05-05 lun 22:20
% Intended LaTeX compiler: pdflatex
\documentclass[titlepage,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\hypersetup{colorlinks=true,linkcolor=black,urlcolor=blue,bookmarksopen=true}
\usepackage{a4wide}
\usepackage{bookmark}
\usepackage{fancyhdr}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{minted}
\usepackage{svg}
\usepackage{xcolor}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{TP1 - Grupo 2}
\fancyhead[R]{Redes - FIUBA}
\renewcommand{\headrulewidth}{0.4pt}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{0.4pt}
\usemintedstyle{stata-light}
\newminted{c}{bgcolor={rgb}{0.95,0.95,0.95}}
\usepackage{color}
\usepackage[utf8]{inputenc}
\usepackage{fancyvrb}
\fvset{framesep=1mm,fontfamily=courier,fontsize=\scriptsize,numbers=left,framerule=.3mm,numbersep=1mm}
\usepackage[nottoc]{tocbibind}
\usepackage{amsmath}
\usepackage{changepage}
\author{Vicky}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={Vicky},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.1 (Org mode 9.3)}, 
 pdflang={Spanish}}
\begin{document}

\begin{titlepage}
    \hfill\includegraphics[width=6cm]{docs/imgs/logofiuba.jpg}
    \centering
    \vfill
    \Huge \textbf{Trabajo Práctico 1}
    \vskip2cm
    \Large [TA048] Redes \\
    Primer cuatrimestre de 2025\\
    \vfill
    \begin{tabular}{ | l | l | l | }
      \hline
      Alumno & Padron & Email \\ \hline
      AVALOS, Victoria & 108434 & vavalos@fi.uba.ar \\ \hline
      CASTRO MARTINEZ, Jose Ignacio & 106957 & jcastrom@fi.uba.ar \\ \hline
      CIPRIANO, Victor & 106593 & vcipriano@fi.uba.ar \\ \hline
      DEALBERA, Pablo Andres & 106858 & pdealbera@fi.uba.ar \\ \hline
      DIEM, Walter Gabriel & 105618 & wdiem@fi.uba.ar \\ \hline
    \end{tabular}
    \vfill
\end{titlepage}
\tableofcontents
\newpage
\definecolor{bg}{rgb}{0.95,0.95,0.95}

\section{Introducción}
\label{sec:org255e430}

En el presente trabajo práctico se desarrolla una aplicación de red para la transferencia de archivos, basada en una arquitectura
cliente-servidor, donde un servidor puede atender las operaciones de múltiples clientes de manera concurrente, con el objetivo principal de implementar mecanismos de transferencia de datos confiable. Para ello, se trabajará
sobre la capa de transporte, utilizando específicamente el protocolo UDP, lo cual requiere diseñar e implementar soluciones
personalizadas que garanticen la entrega de datos confiable (RDT - Reliable Data Transfer).

En este marco, se explorarán los principios del concepto de RDT, implementando dos de sus variantes: Stop-and-Wait (SAW) y Go-Back-N (GBN). La comunicación entre procesos se llevará a cabo mediante la interfaz de sockets de Python, y se utilizará la herramienta Mininet para simular diferentes
condiciones de red y evaluar el comportamiento de las implementaciones, incluyendo escenarios con pérdida de paquetes.


\section{Hipótesis y suposiciones realizadas}
\label{sec:org6249534}

\begin{itemize}
\item La carga/descarga no va a conservar la metadata del archivo. Es decir, si yo descargo un archivo, ese archivo va a tener metadata como si yo hubiera creado el archivo desde cero usando `touch archivo`.
\item Si el cliente utiliza otro protocolo para comunicarse con el server, el server debe rechazar este pedido, esta condición se la denominará \textbf{protocol mismatch}. El header tendrá un campo dedicado a la versión del protocolo.
\item El argumento de FILENAME sera opcional, en caso de no estar, se utiliza el nombre original del archivo.
\item Por simplicidad, vamos a guardar todos los archivos en DIRPATH sin ningún nivel de subdirectorios.
\item Si no se provee un DIRPATH para el storage del servidor, se utiliza el directorio actual.
\item Se verifica que hayan 100 megas disponibles en el disco para realizar un upload al server.
\item Si se cancela la carga o la descarga sin haberse finalizado correctamente, el archivo se borra.
\item Si no se provee puerto por defecto se usa el 7777.
\item Si no se provee un host por defecto será 127.0.0.1.
\item El cliente hace un early bind con cualquier puerto UDP abierto disponible para uso justo antes de enviar el primer mensaje.
\item Tanto el server como el cliente finalizan la conexión después de 30 segundos sin respuesta. También la conexión puede ser finalizada por exceder 300 retransmisiones del mismo paquete de manera continua.
\item Se eliminan los archivos corruptos no enviados/recibidos de manera completa.
\end{itemize}

\section{Implementación}
\label{sec:orgc26d5ca}
\subsection{Topología propia LinearEnds}
\label{sec:org21baf55}

\begin{center}
\includegraphics[width=0.5\textwidth]{docs/imgs/linear_ends_multiple_clients_with_loss.png}
\end{center}

La topología diseñada es una red lineal con 1 host servidor (izquierda) conectado a 3 switches en serie cuyo ultimo switch esta conectado a \textbf{n} hosts clientes (derecha). El primer enlace (el conectado entre el servidor y el primer switch) tiene configurado un packet loss del 10\% configurado de forma simetrica 5\% en cada extremo del enlace.


\subsection{Especificación del protocolo Stop-and-Wait}
\label{sec:org61891ee}

\subsubsection{General}
\label{sec:orgec9813b}


\textbf{Formato de mensaje SaW}: \\


\begin{verbatim}
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Pr|S|A|Y|F|     Unused      |               Port              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Payload Length       |               Data              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---------------------------------+
|                           Data                                |
+---------------------------------------------------------------+
\end{verbatim}

Donde:

\begin{itemize}
\item \texttt{Pr}: son los bits que determinan el protocolo (0 para SAW y 1 para GBN)
\item \texttt{S}: es el bit field que representa el sequence number, puede ser 0 o 1.
\item \texttt{A}: es el flag booleano que representa si el mensaje es un ACK o no.
\item \texttt{Y}: es el flag booleano que representa si el mensaje es SYN o no.
\item \texttt{F}: es el flag booleano que representa si el mensaje es FIN o no.
\item \texttt{Unused}: es una porción de bits que no se usa y queda como padding para completar el tamaño de un short unsigned int (2 bytes).
\item \texttt{Port}: el puerto con el que el receptor del mensaje debe comunicarse, se usa para el cambio de puerto.
\item \texttt{Payload length}: short unsigned int que representa el largo de la data que contiene el paquete.
\item \texttt{Data}: información binaria (bytes) que son los datos a transportar.
\end{itemize}

El header tiene un tamaño de 6 bytes. \\


\textbf{Tamaño máximo de payload} \\


El tamaño máximo de payload permitido por el protolo está basado en el MTU establecido en el estándar Ethernet, es decir, 1500 bytes. Teniendo en cuenta que esto debería ser lo máximo que transporte un paquete de IP, se toman estos 1500 bytes como base, se le resta el tamaño de un header máximo de IP (60 bytes), lo mismo con el header de UDP (8 bytes) y se le resta el tamaño de header del protocolo (6 bytes). Quedando así un payload máximo de 1426 bytes.


\subsubsection{Handshake}
\label{sec:org0296ddd}

\begin{center}
\includegraphics[width=0.5\textwidth]{docs/imgs/connection-handshake.png}
\end{center}

La idea es usar este handshake para inicialización de recursos del servidor y check de protocolo (que no haya protocol mismatch). \\

Se usa la nomenclatura S para mencionar al servidor y C para el cliente.

\uline{Mensajes para caso Download y caso Upload}:

\begin{enumerate}
\item C \(\rightarrow\) S: con flag SYN para declarar una solicitud de conexión y el protocolo
\end{enumerate}

\textbf{Flujo normal (mismo protocolo)}:

\begin{enumerate}
\setcounter{enumi}{1}
\item S \(\rightarrow\) C: con flag de SYN y ACK para declarar que se acepta la conexión y el puerto donde se va a escuchar el resto.
\item C \(\rightarrow\) S: con flag ACK al mismo welcoming socket.
\end{enumerate}

\textbf{Flujo de error (distinto protocolo)}:

\begin{enumerate}
\setcounter{enumi}{1}
\item S \(\rightarrow\) C: con flag FIN para denegar la conexión por usar un protocolo distinto (protocol mismatch).
\end{enumerate}

Se hace una transferencia de puerto para que el welcoming socket se encargue solamente de establecer conexiones y el nuevo puerto maneje la transferencia de datos del archivo. El último ACK de parte del cliente asegura que se recibió el puerto donde se tiene que comunicar y es seguro hacer el cambio de socket.

\subsubsection{Etapa de configuración y Transferencia}
\label{sec:org9f0f05d}

El cliente ya sabe que tiene que comunicarse con el nuevo puerto.

Se envía primero la configuración para saber si la operación es válida y tener en cuenta casos de error, y luego se hace la transferencia. \\

\uline{Mensajes para caso Download y caso Upload}:

\begin{enumerate}
\item C \(\rightarrow\) S: se declara la operación (OP), que puede ser download (1) o upload (2)
\item S \(\rightarrow\) C: ACK de la operación
\end{enumerate}

\uline{Continuación de mensajes para caso Download}:

\begin{enumerate}
\setcounter{enumi}{2}
\item Mensaje 3 C \(\rightarrow\) S: filename
\end{enumerate}

\textbf{Flujo Normal}:

\begin{enumerate}
\setcounter{enumi}{3}
\item S \(\rightarrow\) C: ACK + comienzo de datos (piggybacked)
\item C \(\rightarrow\) S: ACK
\item S \(\rightarrow\) C: continuacion de datos
\end{enumerate}

\textbf{Flujo de error (no existe un archivo con ese nombre)}:

\begin{enumerate}
\setcounter{enumi}{3}
\item S \(\rightarrow\) C: FIN, se termina la conexión
\end{enumerate}

\uline{Continuación de mensajes para caso Upload}:

\begin{enumerate}
\setcounter{enumi}{2}
\item C \(\rightarrow\) S: filename
\end{enumerate}

\textbf{Flujo de error (ya existe un archivo con ese nombre)}:

\begin{enumerate}
\setcounter{enumi}{3}
\item S \(\rightarrow\) C: FIN, se termina la conexión
\end{enumerate}

\textbf{Flujo normal}:

\begin{enumerate}
\setcounter{enumi}{3}
\item S \(\rightarrow\) C: ACK
\item C \(\rightarrow\) S: filesize
\end{enumerate}

\textbf{Flujo de error (archivo es más grande que el tamaño máximo o [TODO] no hay más espacio en disco)}:

\begin{enumerate}
\setcounter{enumi}{5}
\item S \(\rightarrow\) C: FIN, se termina la conexión
\end{enumerate}

\textbf{Flujo normal}:

\begin{enumerate}
\setcounter{enumi}{5}
\item S \(\rightarrow\) C: ACK
\item C \(\rightarrow\) S: comienzo de datos
\item S \(\rightarrow\) C: ACK
\item C \(\rightarrow\) S: continuacion de datos
\end{enumerate}

\subsubsection{Cierre}
\label{sec:org98303fd}

El flag FIN va piggybacked con la última data para que sea más eficiente. El receptor confirma con un ACK + FIN para que el emisor sepa que le llego la informacion, y por si este se pierde está el último ACK para confirmar el cierre de parte del emisor. \\

\begin{enumerate}
\item Mensajes para caso Download
\label{sec:org99b476c}

\begin{center}
\includegraphics[width=0.5\textwidth]{docs/imgs/download.png}
\end{center}

\begin{enumerate}
\item S \(\rightarrow\) C: ultima data, va piggybacked el flag FIN
\item C \(\rightarrow\) S: ACK + FIN
\item S \(\rightarrow\) C: ACK
\end{enumerate}

\item Mensajes para caso Upload:
\label{sec:orgfe0d5e9}

\begin{center}
\includegraphics[width=0.5\textwidth]{docs/imgs/upload.png}
\end{center}

\begin{enumerate}
\item C \(\rightarrow\) S: ultima data, va piggybacked el flag FIN
\item S \(\rightarrow\) C: ACK + FIN
\item C \(\rightarrow\) S: ACK
\end{enumerate}
\end{enumerate}

\subsubsection{Ejemplo del Ciclo de Vida}
\label{sec:orgbb6de71}



\subsection{Especificación del protocolo Go-Back-N}
\label{sec:orgb37dedc}

\subsubsection{General}
\label{sec:org4250e97}

\textbf{Formato de mensaje GBN}: \\

\begin{verbatim}
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Pr|A|Y|F|       Unused      |               Port              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Payload length                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Sequence number                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Acknowledge number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+---------------------------------------------------------------+
\end{verbatim}

Donde:

\begin{itemize}
\item \texttt{Pr}: son los bits que determinan el protocolo (0 para SAW y 1 para GBN)
\item \texttt{A}: es el flag booleano que representa si el mensaje es un ACK o no.
\item \texttt{Y}: es el flag booleano que representa si el mensaje es SYN o no.
\item \texttt{F}: es el flag booleano que representa si el mensaje es FIN o no.
\item \texttt{Unused}: es una porción de bits que no se usa y queda como padding para completar el tamaño de un short unsigned int (2 bytes).
\item \texttt{Port}: el puerto con el que el receptor del mensaje debe comunicarse, se usa para el cambio de puerto.
\item \texttt{Payload length}: unsigned int (4 bytes) que representa el largo de la data que contiene el paquete.
\item \texttt{Sequence number}: unsigned int (4 bytes) que representa el número de secuencia del paquete.
\item \texttt{Acknowledge number}: unsigned int (4 bytes) que representa el número de acknowledge, usado principalmente para saber cuál fue el último paquete que se recibió.
\item \texttt{Data}: información binaria (bytes) que son los datos a transportar.
\end{itemize}

El header tiene un tamaño de 16 bytes. \\

\textbf{Tamaño máximo de payload} \\

El tamaño se determina análogamente a SAW, sólo que esta vez se le resta el tamaño de header del protocolo (16 bytes). Quedando así un payload máximo de 1416 bytes.


\subsubsection{Ciclo de Vida de Upload}
\label{sec:org2684dd2}

\begin{center}
\includegraphics[width=0.65\textwidth]{docs/imgs/gbn_upload.png}
\end{center}

\subsubsection{Ciclo de Vida de Download}
\label{sec:orgc12a9d6}

\begin{center}
\includegraphics[width=0.7\textwidth]{docs/imgs/gbn_download.png}
\end{center}

\subsubsection{Análisis del Ciclo de Vida de Download de una transferencia con Go-Back-N}
\label{sec:org943d899}

Se observa el comportamiento de una transferencia de archivos con una ventana de tamaño 2. En
este caso, el cliente descarga un archivo (`report.pdf`) de 3000 bytes desde el servidor.

\begin{enumerate}
\item Establecimiento de la conexión (Handshake):
\label{sec:orgdb02936}
\begin{itemize}
\item El cliente inicia la conexión enviando un paquete con el flag \texttt{SYN}, con \texttt{seq=0} y \texttt{ack=0}.
\item El servidor responde con un paquete con flags \texttt{SYN} y \texttt{ACK} manteniendo los mismos valores de \texttt{seq} y \texttt{ack}.
\item El cliente confirma la recepción enviando un paquete \texttt{ACK} con \texttt{seq=1} y \texttt{ack=1}, incluyendo en datos la configuración del codigo de operacion (en este caso de descarga) \texttt{data=1 (op\_code)}.
\item El servidor responde con un \texttt{ACK} para confirmar la recepción del mensaje de configuración.
\end{itemize}

\item Configuración:
\label{sec:org163f6f1}
\begin{itemize}
\item El cliente envía un paquete con \texttt{seq=2}, \texttt{ack=2} y \texttt{data=report.pdf}, indicando el nombre del archivo a descargar.
\item El servidor responde con un paquete de datos con \texttt{seq=2}, \texttt{ack=2}, una \texttt{size} de 1416 bytes y los primeros bits del archivo.
\item El cliente confirma la recepción con un \texttt{ACK} correspondiente.
\end{itemize}

\item Transferencia del archivo:
\label{sec:org6b8a7ad}
\begin{itemize}
\item El servidor envía el segundo \texttt{chunk} de datos (\texttt{seq=3}, \texttt{ack=2}), también de 1416 bytes.
\item Posteriormente, se envía un paquete con el flag \texttt{FIN} (\texttt{seq=4}, \texttt{ack=2}, \texttt{payload\_length=168}), marcando el fin de la transferencia.
\item El cliente responde con dos \texttt{ACK}, uno para cada paquete recibido correctamente: \texttt{seq=3, ack=3} y \texttt{seq=4, ack=4}.
\end{itemize}

\item Cierre de la conexión (Closing handshake):
\label{sec:org19f49dd}
\begin{itemize}
\item El cliente envía un \texttt{FIN} para finalizar su lado de la comunicación (\texttt{seq=4, ack=4}).
\item El servidor responde con un \texttt{ACK} final (\texttt{seq=5, ack=5}), completando el cierre de la conexión de manera ordenada.
\end{itemize}
\end{enumerate}

\section{Pruebas}
\label{sec:org797166e}

Se presentan capturas de diferentes casos de uso de la aplicación.

\subsection{Casos de error}
\label{sec:orgd3a5376}

\begin{itemize}
\item Protocol Mismatch
\end{itemize}

\noindent \includegraphics[width=\textwidth]{docs/imgs/protocol_mismatch.png}
\captionof{figure}{Ejemplo de protocol mismatch.}

En caso de que un cliente intente conectarse con un servidor utilizando un protocolo diferente al suyo, el servidor lo rechazará. En la imagen se puede observar un ejemplo en el que un servidor que utiliza Stop \& Wait rechaza a un cliente que hace una petición con Go Back N.

\begin{itemize}
\item Archivo ya existente
\end{itemize}

\noindent \includegraphics[width=\textwidth]{docs/imgs/file_already_exists.png}
\captionof{figure}{Ejemplo de upload de un archivo que ya existe en el servidor.}

Para ambos protocolos, si el cliente intenta subir un archivo que el servidor ya tiene, se rechaza.

\begin{itemize}
\item Descarga de un archivo que no existe
\end{itemize}

\noindent \includegraphics[width=\textwidth]{docs/imgs2/error_file_doesnt_exist.png}
\captionof{figure}{Ejemplo de intento de descarga de un archivo que no existe.}

Para ambos protocolos, si el cliente intenta descargar un archivo que el servidor no posee, se rechaza.

\subsection{Stop \& Wait}
\label{sec:org595e39d}

Para mostrar el funcionamiento de Stop \& Wait, mostraremos las capturas de las operaciones upload y download de un archivo pequeño de 5kB a modo de ejemplo. Primero sin pérdida de paquetes, y luego con una pérdida del 10\% utilizando mininet.

\subsubsection{Stop \& Wait sin pérdida de paquetes}
\label{sec:orga10d4d8}

\begin{itemize}
\item Upload
\end{itemize}

\noindent \includegraphics[width=\textwidth]{docs/imgs/saw_upload.png}
\captionof{figure}{Captura de los logs de Upload con Stop and Wait.}


\noindent \includegraphics[width=\textwidth]{docs/imgs/saw_upload_wireshark.png}
\captionof{figure}{Captura de wireshark de Upload con Stop and Wait.}

\begin{itemize}
\item Download
\end{itemize}

\noindent \includegraphics[width=\textwidth]{docs/imgs/saw_download.png}
\captionof{figure}{Captura de los logs de Download con Stop and Wait.}

\noindent \includegraphics[width=\textwidth]{docs/imgs/saw_download_wireshark.png}
\captionof{figure}{Captura de wireshark de Download con Stop and Wait.}

\subsubsection{Stop \& Wait con pérdida de paquetes del 10\%}
\label{sec:org2ccc590}

\begin{itemize}
\item Upload
\end{itemize}

\noindent \includegraphics[width=\textwidth]{docs/imgs2/saw_10l_up.png}
\captionof{figure}{Captura de los logs de Upload con Stop and Wait con pérdida del 10 por ciento.}


\noindent \includegraphics[width=\textwidth]{docs/imgs2/saw_10l_up_ws.png}
\captionof{figure}{Captura de wireshark de Upload con Stop and Wait con pérdida del 10 por ciento.}

\begin{itemize}
\item Download
\end{itemize}

\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_up.png}
\captionof{figure}{Captura de los logs de Download con Stop and Wait con pérdida del 10 por ciento.}

\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_up_ws.png}
\captionof{figure}{Captura de wireshark de Download con Stop and Wait con pérdida del 10 por ciento.}

\subsection{Go Back N}
\label{sec:org2d491d9}

Para mostrar el funcionamiento de Go Back N, mostraremos las capturas de las operaciones upload y download del mismo archivo de 5kB. Para este caso, mostraremos únicamente el caso con pérdida de paquetes, ya que el escenario con pérdida resulta muy similar al de Stop \& Wait debido a que la ventana que utilizamos es mayor a la cantidad de paquetes que posee este archivo.


\begin{itemize}
\item Upload
\end{itemize}

\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_up.png}
\captionof{figure}{Captura de los logs de Upload con Go Back N.}


\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_up_ws.png}
\captionof{figure}{Captura de wireshark de Upload con Go Back N.}

\begin{itemize}
\item Download
\end{itemize}

\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_down.png}
\captionof{figure}{Captura de los logs de Download con Go Back N.}

\noindent \includegraphics[width=\textwidth]{docs/imgs2/gbn_10l_down_ws.png}
\captionof{figure}{Captura de wireshark de Download con Go Back N.}

\section{Preguntas a Responder}
\label{sec:org28245b8}
\subsection{Describa la arquitectura Cliente-Servidor.}
\label{sec:org981f657}
La arquitectura Cliente-Servidor es una de dos arquitecturas más comunes. En esta arquitectura hay un \emph{host} (\emph{end system}) llamado \emph{server} que esta siempre encendido que pasivamente escucha \emph{requests} de otros \emph{hosts} llamados \emph{clients} que son agentes activos que inician la comunicación con el \emph{server}.

Un ejemplo de esta arquitectura es una aplicacion Web donde hay un \emph{Web server} que escucha \emph{requests} de navegadores web. El navegador web es el cliente que inicia la comunicación y el \emph{Web server} es el servidor que responde a los \emph{requests}. Estos mensajes tienen el formato de Capa de Aplicación HTTP.

\subsubsection{Caracteristicas}
\label{sec:org6c03aa3}
\begin{itemize}
\item Los clientes son agentes activos que inician la comunicación.
\item Los clientes no se comunican entre si.
\item Los clientes no necesitan estar encendidos todo el tiempo ni tener una IP fija.
\item Los servidores son pasivos y siempre están encendidos.
\item Los servidores \textbf{deben} tener una IP fija bien conocida (\emph{well-known IP address}) que se puede resolver con un nombre de dominio DNS (\emph{domain name}).
\item Los servidores pueden tener múltiples clientes conectados al mismo tiempo.
\end{itemize}

\subsubsection{Ventajas}
\label{sec:org69ab8d4}
\begin{itemize}
\item Diseño simple usando protocolos sin estado como HTTP donde el servidor no
necesita mantener informacion sobre clientes ya que se puede guardar
informacion del cliente en \emph{cookies} del cliente y estos se transmitidos en
\emph{headers} HTTP.
\item Puede soportar un gran numero de clientes.
\end{itemize}

\subsubsection{Desventajas}
\label{sec:orgadd937b}
\begin{itemize}
\item Un solo punto de falla. Si el servidor se cae, el servicio se cae.
\item El servidor debe estar encendido todo el tiempo.
\item Gran costo para escalar, ya que a medida de que el servicio tiene mas
usuarios, el servidor debe tambien aumentar su capacidad de procesar mas
clientes.
\end{itemize}

\subsection{¿Cuál es la función de un protocolo de capa de aplicación?}
\label{sec:org7b3945f}

Un protocolo de capa de aplicación especifica cómo los procesos de una aplicación, que se ejecutan en diferentes sistemas finales, intercambian mensajes entre sí. Este tipo de protocolo define:

\begin{itemize}
\item Los tipos de mensajes que se envían, como mensajes de solicitud y de respuesta.

\item La sintaxis de los mensajes, es decir, la estructura de los campos dentro de cada mensaje y cómo se separan o identifican esos campos.

\item La semántica de los campos, indicando qué significa la información contenida en cada uno.

\item Las reglas de comunicación, que establecen cuándo un proceso debe enviar un mensaje y cómo debe reaccionar al recibir uno.
\end{itemize}

En resumen, los protocolos de capa de aplicación aseguran que las aplicaciones puedan comunicarse correctamente y coordinarse en la red, haciendo posible servicios como el correo electrónico, la web o la transferencia de archivos.

\subsection{Detalle el protocolo de aplicación desarrollado en este trabajo.}
\label{sec:orgea9a366}

\subsection{La capa de transporte del stack TCP/IP ofrece dos protocolos: TCP y UDP.}
\label{sec:orga9ab394}

\subsubsection{¿Qué servicios proveen dichos protocolos?}
\label{sec:orgf6f203e}

Ambos protocolos proveen los siguientes servicios:

\begin{itemize}
\item \textbf{Multiplexación/Demultiplexación}: son los mecanismos que permiten extender el servicio de entrega de IP entre dos end systems a un servicio de entrega entre dos procesos que se ejecutan en esos sistemas. Dichos mecanismos permiten identificar a qué proceso pertenece cada ssegmento recibido.
\item \textbf{Chequeo de integridad}: se verifica que no haya errores en los datos mediante un campo de checksum en los headers de ambos protocolos.
\end{itemize}

UDP no realiza ninguna otra función extra. Por lo tanto, su servicio es:
\begin{itemize}
\item \textbf{No confiable}: no garantiza que la entrega de los paquetes sea exitosa, ni tampoco que lleguen en orden.
\item \textbf{Sin conexión}: cada paquete datagrama se envía de manera independiente, sin garantías de que el receptor esté listo o incluso disponible.
\end{itemize}

Por su parte, TCP ofrece las siguientes funcionalidades adicionales:
\begin{itemize}
\item \textbf{Orientado a la conexión}: antes de que un proceso de aplicación pueda comenzar a enviar datos a otro, ambos procesos deben comunicarse entre sí; es decir, deben enviarse algunos segmentos preliminares para establecer los parámetros de la transferencia de datos subsiguiente. Se trata de una conexión lógica con un estado en común que reside en TCP de los hosts.
\item \textbf{Transferencia de datos confiable}: garantiza la entrega, el orden y la no corrupción de los datos. Esto lo logra mediante timers, numeros de secuencia y ACKs (flags que indican que un paquete fue entregado correctamente).
\item \textbf{Control de congestión}: festiona que no se saturen los enlaces. Es más bien un servicio para la red.
\item \textbf{Control de flujo}: para eliminar la posibilidad de que el remitente desborde el búfer del receptor. Hace coincidir la velocidad a la que el remitente envía con la velocidad a la que la aplicación receptora lee.
\end{itemize}

\subsubsection{¿Cuáles son sus características?}
\label{sec:org4626f3f}

Algunas de las características de UDP son las siguientes:
\begin{itemize}
\item \textbf{Pequeño overhead de header por paquete}: UDP posee un header pequeño (8 bytes) en comparación con TCP (20 bytes)
\item \textbf{Sin estado de conexión}: UDP no mantiene un estado de conexión en los end systems, por lo que no rastrea ningún parámetro. Por esta razón, un servidor dedicado a una aplicación específica generalmente puede admitir muchos más clientes activos cuando la aplicación se ejecuta mediante UDP en lugar de TCP.
\item \textbf{Sin retraso por conexión}: UDP no induce ningún retraso para establecer una conexión, a diferencia de TCP que posee un handshake de tres pasos.
\end{itemize}

Por su parte, TCP posee las siguientes características:

\begin{itemize}
\item \textbf{Full-duplex}: dada una conexión TCP entre dos hosts, digamos A y B, la información puede fluir de A a B al mismo tiempo que fluye información de B a A.
\item \textbf{Conexión point-to-point}: la conexión de TCP únicamente se puede establecer entre un único remitente y un único receptor, no admite multicasting.
\item \textbf{Three-Way Handshake}: para establecer la conexión mencionada anteriormente se realiza un procedimiento donde se envían tres segmentos.
\end{itemize}

\subsubsection{¿Cuando es apropiado utilizar cada uno?}
\label{sec:org5296203}

Ninguno de estos protocolos es mejor que el otro. Para decidir cuál de ellos utilizar, se deben tener en cuenta las necesidades de la aplicación.
Debido a las características mencionadas anteriormente, UDP resulta más apropiado para aplicaciones que requieran mayor velocidad sin que sea tan sensible a algunas pérdidas de paquetes, por ejemplo plataformas de streaming, y si se tiene un servidor dedicado a una aplicación específica que necesita poder admitir muchos más clientes activos.
Por otro lado, TCP es más ventajoso para las aplicaciones que necesitan un transporte confiable de los datos. Algunos ejemplos son el email y la web.
\section{Dificultades Encontradas}
\label{sec:orgc743839}
\section{Conclusión}
\label{sec:org8286132}
\section{Anexo: Fragmentacion IPv4}
\label{sec:org3ba1f21}
\subsection{Consideraciones iniciales}
\label{sec:org5146c2a}

Se propuso inicialmente una red de topología lineal que una a un host servidor, tres switches conectados en serie y un host cliente donde haya pérdida de paquetes en el enlace próximo al host receptor y que el switch central tenga la capacidad de fragmentar paquetes IPv4. Sin embargo, los switches en mininet no tienen la capacidad de fragmentar paquetes, por lo que al forzar fragmentación (es decir, reducir el MTU de alguna de sus interfaces) causaría una pérdida total de todo paquete de tamaño mayor al MTU.

La solución propuesta fue sustituir ese switch central por un "router" central, un tipo de nodo de mininet similar a los hosts pero que además cuenta con la capacidad de hacer forwarding de paquetes IPv4. Conceptualmente un switch, al ser un elemento de Link Layer, no debe tener la capacidad de fragmentar paquetes de otra capa de red.

Otro de los conflictos presentados es la comunicación bidireccional. Reducir el MTU de alguna interfaz de un router implica que se reduce sobre el enlace de esta interfaz. Y si este enlace está conectado a un router y a un switch, la comunicación andará bien en sentido router->switch pero se perderán los paquetes en el sentido switch->router. Por lo que si se desea una comunicación bidireccional en la red y se requiere reducir el MTU de alguna interfaz de la topología esta NO debe estar vinculada a un switch, de lo contrario se perderá todo paquete que exceda el MTU reducido. Dicho esto, se decidió arbitrariamente que basta con tener comunicación unidireccional (C->S) para poder provocar el fenómeno de fragmentación de paquetes IPv4.

\subsection{Análisis}
\label{sec:orga5330bb}
\subsubsection{Topología}
\label{sec:org963456c}
\begin{center}
\includegraphics[width=0.5\textwidth]{docs/frag_imgs/linear_ends_fragmentation_item.png}
\end{center}

Se define una pérdida de 20\% de paquetes sobre el enlace próximo al servidor, un MTU de 800 en la interfaz saliente del router (s2-eth0) y un tamaño de paquetes de 1000B (arbitrariamente, basta con que sea ligeramente superior al MTU reducido) para estudiar este fenómeno.

\subsubsection{Proceso de fragmentación}
\label{sec:orgaec461c}

Habiendo definido la red como se mencionó anteriormente, basta generar tráfico de cliente a servidor usando iperf y capturar los paquetes recibidos y enviados por el router (s2) con Wireshark para estudiar este fenómeno. Por ejemplo:

Paquetes capturados en interfaz de entrada del router (s2-eth1):
No.	Time	Source	Destination	Protocol	Length	Info
\ldots{}
23	1.971521	10.0.1.1	10.0.0.1	TCP	74	54360 → 5001 [SYN] Seq=0 Win=43000 Len=0 MSS=1000 SACK\textsubscript{PERM} TSval=2993150612 TSecr=0 WS=512
24	1.991994	10.0.0.1	10.0.1.1	TCP	74	5001 → 54360 [SYN, ACK] Seq=0 Ack=1 Win=43440 Len=0 MSS=1460 SACK\textsubscript{PERM} TSval=2142019792 TSecr=2993150612 WS=512
25	1.995183	10.0.1.1	10.0.0.1	TCP	66	54360 → 5001 [ACK] Seq=1 Ack=1 Win=43008 Len=0 TSval=2993150645 TSecr=2142019792
26	1.995677	10.0.1.1	10.0.0.1	TCP	126	54360 → 5001 [PSH, ACK] Seq=1 Ack=1 Win=43008 Len=60 TSval=2993150646 TSecr=2142019792
27	1.995841	10.0.0.1	10.0.1.1	TCP	66	5001 → 54360 [ACK] Seq=1 Ack=61 Win=43520 Len=0 TSval=2142019813 TSecr=2993150646
28	1.996044	10.0.0.1	10.0.1.1	TCP	94	5001 → 54360 [PSH, ACK] Seq=1 Ack=61 Win=43520 Len=28 TSval=2142019813 TSecr=2993150646
29	1.996235	10.0.1.1	10.0.0.1	TCP	2042	54360 → 5001 [PSH, ACK] Seq=61 Ack=1 Win=43008 Len=1976 TSval=2993150646 TSecr=2142019792
30	1.996274	10.0.1.1	10.0.0.1	TCP	2042	54360 → 5001 [PSH, ACK] Seq=2037 Ack=1 Win=43008 Len=1976 TSval=2993150646 TSecr=2142019792
\ldots{}

Paquetes capturados en interfaz de salida del router (s2-eth0):
No.	Time	Source	Destination	Protocol	Length	Info
\ldots{}
16	1.893458	10.0.1.1	10.0.0.1	TCP	74	54360 → 5001 [SYN] Seq=0 Win=43000 Len=0 MSS=1000 SACK\textsubscript{PERM} TSval=2993150612 TSecr=0 WS=512
17	1.911142	10.0.0.1	10.0.1.1	TCP	74	5001 → 54360 [SYN, ACK] Seq=0 Ack=1 Win=43440 Len=0 MSS=1460 SACK\textsubscript{PERM} TSval=2142019792 TSecr=2993150612 WS=512
18	1.914359	10.0.1.1	10.0.0.1	TCP	66	54360 → 5001 [ACK] Seq=1 Ack=1 Win=43008 Len=0 TSval=2993150645 TSecr=2142019792
19	1.914855	10.0.1.1	10.0.0.1	TCP	126	54360 → 5001 [PSH, ACK] Seq=1 Ack=1 Win=43008 Len=60 TSval=2993150646 TSecr=2142019792
20	1.915001	10.0.0.1	10.0.1.1	TCP	66	5001 → 54360 [ACK] Seq=1 Ack=61 Win=43520 Len=0 TSval=2142019813 TSecr=2993150646
21	1.915201	10.0.0.1	10.0.1.1	TCP	94	5001 → 54360 [PSH, ACK] Seq=1 Ack=61 Win=43520 Len=28 TSval=2142019813 TSecr=2993150646
22	1.915411	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=TCP 6, off=0, ID=6401) [Reassembled in \#23]
23	1.915413	10.0.1.1	10.0.0.1	TCP	278	54360 → 5001 [ACK] Seq=61 Ack=1 Win=43008 Len=988 TSval=2993150646 TSecr=2142019792
24	1.915415	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=TCP 6, off=0, ID=6402) [Reassembled in \#25]
25	1.915416	10.0.1.1	10.0.0.1	TCP	278	54360 → 5001 [PSH, ACK] Seq=1049 Ack=1 Win=43008 Len=988 TSval=2993150646 TSecr=2142019792
26	1.915444	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=TCP 6, off=0, ID=6403) [Reassembled in \#27]
27	1.915445	10.0.1.1	10.0.0.1	TCP	278	54360 → 5001 [ACK] Seq=2037 Ack=1 Win=43008 Len=988 TSval=2993150646 TSecr=2142019792
28	1.915447	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=TCP 6, off=0, ID=6404) [Reassembled in \#29]
29	1.915448	10.0.1.1	10.0.0.1	TCP	278	54360 → 5001 [PSH, ACK] Seq=3025 Ack=1 Win=43008 Len=988 TSval=2993150646 TSecr=2142019792
30	1.915467	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=TCP 6, off=0, ID=6405) [Reassembled in \#31]
\ldots{}

Se observa que tras establecer la comunicación inicial, se envían paquetes de un tamaño que lleva a forzar que el router fragmente los paquetes TCP recibidos en varios paquetes TCP/IPv4, esto según que tan grande sea la relación tamaño de paquete/MTU del enlace. Se logra identificar que paquete se fragmentó según los números de secuencia que muestra Wireshark en su columna de información, y para paquetes que no tienen número de secuencia coincidente indica que se requirió fragmentar más de una vez.

Si se hace una suma del tamaño de los fragmentos hasta que coincidan paquetes de ambas tablas, se observa como el router termina enviando más bytes de los que recibió. Esto debido a que el reensamblado de paquetes se produce incluyendo encabezados de todas las capas de red.

\subsubsection{Funcionamiento de TCP ante la pérdida de un fragmento}
\label{sec:org84accd1}
TCP es un protocolo de transporte que maneja la retransmisión de datos tras pérdida y detección a partir de ACKs duplicados. Este fenómeno es muy simple de visualizar en Wireshark, donde se señala en la columna de información cuando un paquete corresponde a información retransmitida (Retransmission/Fast Retransmission)

No.	Time	Source	Destination	Protocol	Length	Info
\ldots{}
42	2.002269	10.0.1.1	10.0.0.1	TCP	2042	54360 → 5001 [PSH, ACK] Seq=16857 Ack=1 Win=43008 Len=1976 TSval=2993150652 TSecr=2142019792
41	2.002234	10.0.1.1	10.0.0.1	TCP	2042	54360 → 5001 [PSH, ACK] Seq=14881 Ack=1 Win=43008 Len=1976 TSval=2993150652 TSecr=2142019792
43	2.002311	10.0.1.1	10.0.0.1	TCP	1054	[TCP Fast Retransmission] 54360 → 5001 [ACK] Seq=2037 Ack=1 Win=43008 Len=988 TSval=2993150652 TSecr=2142019792
44	2.002843	10.0.0.1	10.0.1.1	TCP	86	[TCP Dup ACK 34\#4] 5001 → 54360 [ACK] Seq=29 Ack=2037 Win=41984 Len=0 TSval=2142019818 TSecr=2993150646 SLE=5001 SRE=8953 SLE=3025 SRE=4013
45	2.002884	10.0.1.1	10.0.0.1	TCP	1054	[TCP Retransmission] 54360 → 5001 [ACK] Seq=4013 Ack=1 Win=43008 Len=988 TSval=2993150653 TSecr=2142019792
46	2.003232	10.0.1.1	10.0.0.1	TCP	66	54360 → 5001 [ACK] Seq=18833 Ack=29 Win=43008 Len=0 TSval=2993150653 TSecr=2142019792
47	2.005101	10.0.0.1	10.0.1.1	TCP	86	[TCP Dup ACK 34\#5] 5001 → 54360 [ACK] Seq=29 Ack=2037 Win=41984 Len=0 TSval=2142019821 TSecr=2993150646 SLE=5001 SRE=9941 SLE=3025 SRE=4013
48	2.005135	10.0.1.1	10.0.0.1	TCP	1054	54360 → 5001 [ACK] Seq=18833 Ack=29 Win=43008 Len=988 TSval=2993150655 TSecr=2142019821
49	2.005341	10.0.0.1	10.0.1.1	TCP	94	[TCP Dup ACK 34\#6] 5001 → 54360 [ACK] Seq=29 Ack=2037 Win=41984 Len=0 TSval=2142019822 TSecr=2993150646 SLE=5001 SRE=11917 SLE=18833 SRE=19821 SLE=3025 SRE=4013
50	2.005364	10.0.1.1	10.0.0.1	TCP	1054	[TCP Fast Retransmission] 54360 → 5001 [ACK] Seq=2037 Ack=29 Win=43008 Len=988 TSval=2993150655 TSecr=2142019822
51	2.005371	10.0.1.1	10.0.0.1	TCP	1054	[TCP Retransmission] 54360 → 5001 [ACK] Seq=4013 Ack=29 Win=43008 Len=988 TSval=2993150655 TSecr=2142019822
52	2.005376	10.0.1.1	10.0.0.1	TCP	1054	[TCP Retransmission] 54360 → 5001 [ACK] Seq=11917 Ack=29 Win=43008 Len=988 TSval=2993150655 TSecr=2142019822
53	2.005382	10.0.1.1	10.0.0.1	TCP	1054	[TCP Retransmission] 54360 → 5001 [ACK] Seq=12905 Ack=29 Win=43008 Len=988 TSval=2993150655 TSecr=2142019822
54	2.005429	10.0.0.1	10.0.1.1	TCP	94	5001 → 54360 [ACK] Seq=29 Ack=4013 Win=40448 Len=0 TSval=2142019822 TSecr=2993150655 SLE=12905 SRE=13893 SLE=5001 SRE=11917 SLE=18833 SRE=19821
\ldots{}

Este mecanismo garantiza que no se pierden datos durante la comunicación en el caso de pérdida de paquetes. Para esta experiencia, como se fuerza la fragmentación de paquetes IPv4 antes del enlace con pérdida de paquetes, en su mayoría lo que se retransmite son fragmentos IPv4 perdidos, esto salvo que se pierdan datos referentes a la conexión como los ACKs de handshake/cierre de conexión u otros paquetes como la actualización de ventanas de transmisión. Dicho esto, el fenómeno de retransmisión de paquetes es el mismo para todo tipo de paquete del protocolo.

Capturando el output del comando iperf (ejecutado durante 3 segundos) se puede observar el resultado final de la comunicación en cliente y servidor:

Cliente:
\begin{center}
\includegraphics[width=0.5\textwidth]{docs/frag_imgs/iperf_client_tcp.png}
\end{center}

Servidor:
\begin{center}
\includegraphics[width=0.5\textwidth]{docs/frag_imgs/iperf_server_tcp.png}
\end{center}

\subsubsection{Funcionamiento de UDP ante la pérdida de un fragmento}
\label{sec:org951831c}

TCP no es un protocolo orientado a la transferencia confiable de datos, por lo que NO cuenta con ningún mecanismo tras pérdida de paquetes, solamente envía sin garantía de recepción.

En estas capturas de Wireshark se evidencia como ocurre el fenómeno de fragmentación, donde al solo fragmentar en 2 un paquete UDP en Wireshark se capturará cerca del doble de paquetes en cada interfaz (o más según la relación tamaño/MTU):

Paquetes capturados en interfaz de entrada del router (s2-eth1):
No.	Time	Source	Destination	Protocol	Length	Info
\ldots{}
9	1.125290	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
10	1.126623	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
12	1.126743	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
11	1.126713	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
13	1.126777	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
\ldots{}

Paquetes capturados en interfaz de salida del router (s2-eth0):
\ldots{}
No.	Time	Source	Destination	Protocol	Length	Info
14	1.125302	10.0.1.1	10.0.0.1	UDP	266	55090 → 5001 Len=1000
15	1.126628	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=UDP 17, off=0, ID=bd6e) [Reassembled in \#16]
16	1.126633	10.0.1.1	10.0.0.1	UDP	266	55090 → 5001 Len=1000
17	1.126698	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=UDP 17, off=0, ID=bd6f) [Reassembled in \#18]
13	1.125298	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=UDP 17, off=0, ID=bd6d) [Reassembled in \#14]
18	1.126699	10.0.1.1	10.0.0.1	UDP	266	55090 → 5001 Len=1000
19	1.126727	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=UDP 17, off=0, ID=bd70) [Reassembled in \#20]
20	1.126729	10.0.1.1	10.0.0.1	UDP	266	55090 → 5001 Len=1000
21	1.126763	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=UDP 17, off=0, ID=bd71) [Reassembled in \#22]
22	1.126765	10.0.1.1	10.0.0.1	UDP	266	55090 → 5001 Len=1000
\ldots{}

Sin embargo, al haber pérdida de paquetes cercano al servidor, esta no puede observarse capturando sobre el router sino sobre el servidor, donde se observaría que tantos paquetes se pierden a partir de que tantos envió el cliente. Otra forma más sencilla de observar este fenómeno es con el output del comando iperf ejecutado sobre UDP, donde explícitamente señala que cantidad de paquetes se perdieron.

Cliente:
\begin{center}
\includegraphics[width=0.5\textwidth]{docs/frag_imgs/iperf_client_udp.png}
\end{center}

Servidor:
\begin{center}
\includegraphics[width=0.5\textwidth]{docs/frag_imgs/iperf_server_udp.png}
\end{center}

Donde se observa una pérdida en torno al 20\% definido inicialmente.

\subsubsection{Aumento de tráfico al reducirse el MTU mínimo de la red.}
\label{sec:orgb79e237}

Por último, el fenómeno más sencillo de comprobar. Como se mencionó anteriormente, ya que el router fragmenta paquetes de ambos protocolos de transporte en función de su tamaño y el MTU de la interfaz de salida, siempre va a enviar más paquetes de los que recibe, por lo que se observa un aumento notorio del tráfico en la red. Para esta experiencia, se observa un aumento trabajando con UDP:

Paquetes capturados en interfaz de entrada del router (s2-eth1):
\ldots{}
No.	Time	Source	Destination	Protocol	Length	Info
\ldots{}
3762	4.119552	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
3763	4.120970	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
3764	4.121056	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
3765	4.134780	10.0.1.1	10.0.0.1	UDP	1042	55090 → 5001 Len=1000
3766	4.140611	10.0.0.1	10.0.1.1	UDP	170	5001 → 55090 Len=128

Paquetes capturados en interfaz de salida del router (s2-eth0):
\ldots{}
No.	Time	Source	Destination	Protocol	Length	Info
7519	4.121043	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=UDP 17, off=0, ID=cc13) [Reassembled in \#7520]
7520	4.121046	10.0.1.1	10.0.0.1	UDP	266	55090 → 5001 Len=1000
7521	4.134785	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=UDP 17, off=0, ID=cc14) [Reassembled in \#7522]
7522	4.134792	10.0.1.1	10.0.0.1	UDP	266	55090 → 5001 Len=1000
7523	4.140574	10.0.0.1	10.0.1.1	UDP	170	5001 → 55090 Len=128

Y se observa también un aumento en el tráfico de la red trabajando con TCP:

Paquetes capturados en interfaz de salida del router (s2-eth1):
No.	Time	Source	Destination	Protocol	Length	Info
\ldots{}
495	9.978010	10.0.0.1	10.0.1.1	TCP	78	[TCP Window Update] 5001 → 54360 [ACK] Seq=29 Ack=227301 Win=531968 Len=0 TSval=2142027795 TSecr=2993158628 SLE=228289 SRE=229277
496	9.978020	10.0.1.1	10.0.0.1	TCP	1054	[TCP Retransmission] 54360 → 5001 [ACK] Seq=227301 Ack=29 Win=43008 Len=988 TSval=2993158628 TSecr=2142027795
497	9.985551	10.0.0.1	10.0.1.1	TCP	78	5001 → 54360 [FIN, ACK] Seq=29 Ack=227301 Win=531968 Len=0 TSval=2142027802 TSecr=2993158628 SLE=228289 SRE=229277
498	9.985578	10.0.1.1	10.0.0.1	TCP	66	54360 → 5001 [ACK] Seq=229277 Ack=30 Win=43008 Len=0 TSval=2993158635 TSecr=2142027802
499	10.551816	10.0.1.1	10.0.0.1	TCP	1054	[TCP Retransmission] 54360 → 5001 [ACK] Seq=227301 Ack=30 Win=43008 Len=988 TSval=2993159202 TSecr=2142027802

Paquetes capturados en interfaz de salida del router (s2-eth0):
No.	Time	Source	Destination	Protocol	Length	Info
\ldots{}
820	9.897189	10.0.1.1	10.0.0.1	TCP	278	[TCP Retransmission] 54360 → 5001 [ACK] Seq=227301 Ack=29 Win=43008 Len=988 TSval=2993158628 TSecr=2142027795
821	9.904702	10.0.0.1	10.0.1.1	TCP	78	5001 → 54360 [FIN, ACK] Seq=29 Ack=227301 Win=531968 Len=0 TSval=2142027802 TSecr=2993158628 SLE=228289 SRE=229277
822	9.904745	10.0.1.1	10.0.0.1	TCP	66	54360 → 5001 [ACK] Seq=229277 Ack=30 Win=43008 Len=0 TSval=2993158635 TSecr=2142027802
823	10.471001	10.0.1.1	10.0.0.1	IPv4	810	Fragmented IP protocol (proto=TCP 6, off=0, ID=6534) [Reassembled in \#824]
824	10.471020	10.0.1.1	10.0.0.1	TCP	278	[TCP Retransmission] 54360 → 5001 [ACK] Seq=227301 Ack=30 Win=43008 Len=988 TSval=2993159202 TSecr=2142027802
\end{document}
